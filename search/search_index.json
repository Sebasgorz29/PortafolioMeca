{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"\ud83d\ude80 Proyectos con ESP32 y Arduino","text":"<p>Bienvenidos a todos en este grupo de pr\u00e1cticas t\u00e9cnicas con microcontroladores. Aqu\u00ed encontrar\u00e1s documentaci\u00f3n clara, c\u00f3digo funcional y evidencias de proyectos realizados con ESP32 y Arduino. Cada pr\u00e1ctica explora conceptos clave de electr\u00f3nica, programaci\u00f3n y control f\u00edsico.</p>"},{"location":"#indice-de-practicas","title":"\ud83d\udcda \u00cdndice de Pr\u00e1cticas","text":""},{"location":"#comunicacion-bluetooth-entre-esp32-y-celular","title":"\ud83d\udd35 Comunicaci\u00f3n Bluetooth entre ESP32 y Celular","text":"<p>Establece una conexi\u00f3n inal\u00e1mbrica entre un ESP32 y un celular para recibir mensajes en tiempo real.</p>"},{"location":"#encendido-de-led-con-pulsador-usando-arduino","title":"\ud83d\udd34 Encendido de LED con Pulsador usando Arduino","text":"<p>Controla un LED mediante un bot\u00f3n f\u00edsico, aplicando l\u00f3gica digital y resistencias pull-down.</p>"},{"location":"#control-de-giro-velocidad-y-posicion-con-esp32","title":"\u2699\ufe0f Control de Giro, Velocidad y Posici\u00f3n con ESP32","text":"<p>Manipula motores DC y servos usando PWM y mapeo de valores para posicionamiento preciso.</p>"},{"location":"#vehiculo-controlado-por-bluetooth-con-motores-dc","title":"\ud83d\ude97 Veh\u00edculo Controlado por Bluetooth con Motores DC","text":"<p>Dise\u00f1a y programa un coche rob\u00f3tico con ESP32, puente H y control remoto v\u00eda Bluetooth.</p>"},{"location":"#tecnologias-utilizadas","title":"\ud83d\udcce Tecnolog\u00edas Utilizadas","text":"<ul> <li>\ud83e\udde0 Microcontroladores: ESP32, Arduino UNO  </li> <li>\ud83d\udcbb Software: Arduino IDE, SolidWorks, PSeInt  </li> <li>\ud83d\udd27 Lenguajes: C++, Python  </li> <li>\ud83d\udcf2 Comunicaci\u00f3n: Bluetooth, PWM, l\u00f3gica digital  </li> </ul>"},{"location":"ESP32yCelular/","title":"\ud83d\udcf6 Comunicaci\u00f3n Bluetooth entre ESP32 y Celular","text":""},{"location":"ESP32yCelular/#proposito","title":"\ud83c\udfaf Prop\u00f3sito","text":"<p>Establecer una comunicaci\u00f3n inal\u00e1mbrica entre un ESP32 y un tel\u00e9fono celular mediante Bluetooth, para enviar mensajes desde la app de Arduino y visualizar los textos recibidos en el monitor serial de la computadora.</p>"},{"location":"ESP32yCelular/#meta-de-la-practica","title":"\ud83e\udded Meta de la pr\u00e1ctica","text":"<p>Lograr que el ESP32 reciba mensajes escritos desde una app m\u00f3vil y los muestre en el monitor serial de la computadora a trav\u00e9s de una conexi\u00f3n Bluetooth.</p>"},{"location":"ESP32yCelular/#organizacion-del-equipo","title":"\ud83d\udc65 Organizaci\u00f3n del Equipo","text":"<p>La organizaci\u00f3n fue eficaz: el equipo se dividi\u00f3 en dos \u00e1reas principales: - Desarrollo del c\u00f3digo de programaci\u00f3n - Desarrollo electr\u00f3nico</p>"},{"location":"ESP32yCelular/#materiales-utilizados","title":"\ud83e\uddf0 Materiales Utilizados","text":"<ul> <li>ESP32  </li> <li>Protoboard  </li> <li>Cables de conexi\u00f3n (jumpers)  </li> <li>Cable USB para cargar el programa  </li> <li>Aplicaci\u00f3n Arduino Bluetooth Controller (en celular Android)  </li> <li>Computadora con Arduino IDE  </li> </ul>"},{"location":"ESP32yCelular/#tecnologias-utilizadas","title":"\ud83e\uddea Tecnolog\u00edas Utilizadas","text":"<ul> <li>Lenguajes: Python  </li> <li>Hardware: ESP32, Arduino  </li> <li>Software: Arduino IDE  </li> <li>Sistema Electr\u00f3nico: Comunicaci\u00f3n Bluetooth sin sensores ni actuadores externos</li> </ul>"},{"location":"ESP32yCelular/#funcion-del-esp32","title":"\ud83e\udde0 Funci\u00f3n del ESP32","text":"<p>El ESP32 se conect\u00f3 a la computadora mediante USB. No se utilizaron sensores ni actuadores, ya que el enfoque fue exclusivamente en la comunicaci\u00f3n Bluetooth. Se configur\u00f3 como servidor Bluetooth para que el celular pudiera detectarlo y conectarse.</p>"},{"location":"ESP32yCelular/#programacion","title":"\ud83d\udce1 Programaci\u00f3n","text":"<p>Este proyecto permite establecer una comunicaci\u00f3n inal\u00e1mbrica entre un ESP32 y un tel\u00e9fono celular mediante Bluetooth. El objetivo es recibir mensajes escritos desde una app m\u00f3vil y mostrarlos en el monitor serial de la computadora.</p>"},{"location":"ESP32yCelular/#flujo-del-codigo","title":"\ud83d\udd27 Flujo del c\u00f3digo","text":"<ol> <li>Librer\u00eda Bluetooth</li> <li>Se incluye <code>BluetoothSerial.h</code> para habilitar la comunicaci\u00f3n Bluetooth.</li> <li> <p>Se crea el objeto <code>SerialBT</code> para manejar la conexi\u00f3n.</p> </li> <li> <p>Configuraci\u00f3n inicial (<code>setup()</code>)</p> </li> <li>Se inicia la comunicaci\u00f3n serial con <code>Serial.begin(115200)</code>.</li> <li>Se activa el Bluetooth con <code>SerialBT.begin(\"ESP32A\u00d1\")</code>.</li> <li> <p>Se imprime un mensaje indicando que el Bluetooth est\u00e1 listo.</p> </li> <li> <p>Ciclo principal (<code>loop()</code>)</p> </li> <li>Se verifica si hay datos disponibles con <code>SerialBT.available()</code>.</li> <li>Si se detecta un mensaje:<ul> <li>Se lee con <code>SerialBT.readString()</code>.</li> <li>Se muestra en el monitor serial con <code>Serial.println()</code>.</li> </ul> </li> <li>Se incluye un retraso de 1 segundo (<code>delay(1000)</code>) para evitar sobrecarga.</li> </ol>"},{"location":"ESP32yCelular/#aplicacion","title":"\ud83d\udcf2 Aplicaci\u00f3n","text":"<p>Este c\u00f3digo convierte al ESP32 en un receptor Bluetooth que recibe texto desde un celular y lo muestra en tiempo real en la computadora. Es \u00fatil para proyectos de: - Comunicaci\u00f3n inal\u00e1mbrica - Monitoreo de datos - Control remoto b\u00e1sico</p>"},{"location":"ESP32yCelular/#resultados-y-observaciones","title":"\ud83d\udcc8 Resultados y Observaciones","text":"<ul> <li>La conexi\u00f3n Bluetooth fue exitosa y estable.  </li> <li>Los mensajes enviados desde el celular se reflejaron correctamente en el monitor serial.  </li> <li>El ESP32 respondi\u00f3 de forma inmediata.  </li> <li>No se presentaron errores de transmisi\u00f3n ni desconexiones durante la prueba.</li> </ul>"},{"location":"ESP32yCelular/#codigo","title":"Codigo","text":"<pre><code>#include \"BluetoothSerial.h\"   \n\nBluetoothSerial SerialBT;      \nvoid setup() {\n  Serial.begin(115200);       \n  SerialBT.begin(\"ESP32A\u00d1\");   \n  Serial.println(\"Bluetooth listo. Esperando conexi\u00f3n...\");\n}\n\nvoid loop() {\n  if (SerialBT.available()) {                \n    String mensaje = SerialBT.readString();  \n    Serial.println(\"Recibido: \" + mensaje);  \n  delay(1000);  \n}\n</code></pre>"},{"location":"ESP32yCelular/#evidencias","title":"\ud83d\udcf9 Evidencias","text":"<p>Evidencias en video aqu\u00ed.</p>"},{"location":"EncendidodeLED/","title":"\ud83d\udca1 Encendido del LED con Pulsador usando Arduino","text":""},{"location":"EncendidodeLED/#proposito","title":"\ud83c\udfaf Prop\u00f3sito","text":"<p>El objetivo principal de esta pr\u00e1ctica fue llegar a comprender el funcionamiento b\u00e1sico de entradas y salidas digitales en Arduino. Se busc\u00f3 el controlar el encendido de un LED simplemente utilizando un bot\u00f3n f\u00edsico conectado a una protoboard, aplicando conceptos fundamentales de electr\u00f3nica como resistencias pull-down y l\u00f3gica de control.</p>"},{"location":"EncendidodeLED/#meta-de-la-practica","title":"\ud83e\udded Meta de la pr\u00e1ctica","text":"<p>Poder llegar a comprender el funcionamiento de entradas digitales en Arduino y aplicar este conocimiento para controlar un LED asi mediante a un pulsador f\u00edsico.</p>"},{"location":"EncendidodeLED/#organizacion-del-equipo","title":"\ud83d\udc65 Organizaci\u00f3n del Equipo","text":"<p>El equipo se dividi\u00f3 en dos \u00e1reas principales: - Desarrollo del c\u00f3digo de programaci\u00f3n - Desarrollo electr\u00f3nico</p>"},{"location":"EncendidodeLED/#materiales-utilizados","title":"\ud83e\uddf0 Materiales Utilizados","text":"<ul> <li>Arduino UNO  </li> <li>Protoboard  </li> <li>LED rojo  </li> <li>Resistencia de 220\u03a9 (limitadora para el LED)  </li> <li>Resistencia de 10k\u03a9 (pull-down para el bot\u00f3n)  </li> <li>Pulsador (bot\u00f3n)  </li> <li>Cables de conexi\u00f3n (jumpers)  </li> <li>Cable USB para cargar el programa  </li> </ul>"},{"location":"EncendidodeLED/#tecnologias-utilizadas","title":"\ud83e\uddea Tecnolog\u00edas Utilizadas","text":"<ul> <li>Lenguajes: Python  </li> <li>Hardware: ESP32, Arduino  </li> <li>Software: Arduino IDE  </li> </ul>"},{"location":"EncendidodeLED/#sistema-electronico","title":"\u26a1 Sistema Electr\u00f3nico","text":"<p>El circuito se arm\u00f3 sobre una protoboard. El LED se conect\u00f3 al pin digital 13 del Arduino, con una resistencia de 220\u03a9 en serie para evitar sobrecorriente. El bot\u00f3n se conect\u00f3 al pin digital 2, acompa\u00f1ado de una resistencia de 10k\u03a9 como pull-down para asegurar que el estado del pin sea bajo cuando el bot\u00f3n no est\u00e1 presionado. La l\u00f3gica del circuito es simple: - Al presionar el bot\u00f3n, el pin digital lee un estado alto (HIGH) y enciende el LED. - Al soltarlo, el estado vuelve a bajo (LOW) y el LED se apaga.</p>"},{"location":"EncendidodeLED/#programacion","title":"\ud83e\udde0 Programaci\u00f3n","text":"<p>El c\u00f3digo fue escrito en Arduino IDE y se basa en la lectura del estado del bot\u00f3n para controlar el LED. El c\u00f3digo se desarroll\u00f3 en base y apoyo del c\u00f3digo proporcionado por Oliver.</p>"},{"location":"EncendidodeLED/#resultados-y-observaciones","title":"\ud83d\udcc8 Resultados y Observaciones","text":"<p>El circuito respondi\u00f3 correctamente al presionar el bot\u00f3n, encendiendo el LED de forma inmediata. Se comprob\u00f3 que la resistencia pull-down evit\u00f3 lecturas err\u00e1ticas cuando el bot\u00f3n no estaba presionado. La pr\u00e1ctica permiti\u00f3 verificar el funcionamiento b\u00e1sico de entradas y salidas digitales en Arduino, y se logr\u00f3 una interacci\u00f3n estable entre hardware y software.</p>"},{"location":"EncendidodeLED/#reflexion-final","title":"\ud83e\udde9 Reflexion Final","text":"<p>Esta pr\u00e1ctica fue una excelente y educativa introducci\u00f3n al uso de microcontroladores. Puesto que se logr\u00f3 entender c\u00f3mo interact\u00faan los componentes electr\u00f3nicos b\u00e1sicos con el Arduino y c\u00f3mo la programaci\u00f3n puede controlar el comportamiento f\u00edsico de un sistema. Se aprendi\u00f3 la importancia de las resistencias pull-down para evitar lecturas err\u00e1ticas, y se reforz\u00f3 el concepto de entradas y salidas digitales. Adem\u00e1s, se comprob\u00f3 que incluso con un circuito sencillo se pueden lograr interacciones \u00fatiles entre hardware y software.</p>"},{"location":"EncendidodeLED/#codigo","title":"Codigo","text":"<pre><code>const int led=27;\nconst int button=32;\n\nvoid setup() {\n  Serial.begin(115200); //INICIO LA COMUNICACION EN 115200 char por segundo\n  pinMode(led,OUTPUT);\n  pinMode(button,INPUT);\n}\n\nvoid loop() {\n  int estado = digitalRead(button);\n  if(estado == 1){\n    digitalWrite(led,1);\n  }\n  else{\n    digitalWrite(led,0);\n  }\n}\n</code></pre>"},{"location":"EncendidodeLED/#evidencias","title":"\ud83d\udcf9 Evidencias","text":"<p>Evidencias en video aqu\u00ed.</p>"},{"location":"Motor/","title":"\u2699\ufe0f Control de Giro, Velocidad y Posici\u00f3n con ESP32","text":""},{"location":"Motor/#proposito","title":"\ud83c\udfaf Prop\u00f3sito","text":"<p>Explorar el control de motores mediante el ESP32, aplicando t\u00e9cnicas de cambio de giro, variaci\u00f3n de velocidad con PWM y posicionamiento de servo motores.</p>"},{"location":"Motor/#meta-de-la-practica","title":"\ud83e\udded Meta de la pr\u00e1ctica","text":"<p>Poder comprender c\u00f3mo llegar a controlar motores DC y servos utilizando programaci\u00f3n en ESP32, aplicando conceptos de l\u00f3gica digital, modulaci\u00f3n por ancho de pulso (PWM) y mapeo de valores para posicionamiento.</p>"},{"location":"Motor/#organizacion-del-equipo","title":"\ud83d\udc65 Organizaci\u00f3n del Equipo","text":"<p>El equipo se dividi\u00f3 en dos \u00e1reas principales: - Desarrollo del c\u00f3digo de programaci\u00f3n - Desarrollo electr\u00f3nico</p>"},{"location":"Motor/#materiales-utilizados","title":"\ud83e\uddf0 Materiales Utilizados","text":"<ul> <li>ESP32  </li> <li>Motor DC  </li> <li>Servo motor  </li> <li>Protoboard  </li> <li>Cables de conexi\u00f3n (jumpers)  </li> <li>Fuente de alimentaci\u00f3n  </li> <li>Cable USB para cargar el programa  </li> </ul>"},{"location":"Motor/#tecnologias-utilizadas","title":"\ud83e\uddea Tecnolog\u00edas Utilizadas","text":"<ul> <li>Lenguajes: Python  </li> <li>Hardware: ESP32, Arduino  </li> <li>Software: Arduino IDE  </li> </ul>"},{"location":"Motor/#sistema-electronico","title":"\u26a1 Sistema Electr\u00f3nico","text":"<ul> <li>Cambio de giro del motor DC: Se conectaron dos pines digitales al motor, alternando su estado para cambiar la direcci\u00f3n de giro (adelante y atr\u00e1s).  </li> <li>Control de velocidad del motor DC: Se utiliz\u00f3 un pin PWM configurado para incrementar la velocidad del motor.  </li> <li>Control de posici\u00f3n de un servo motor: Se configur\u00f3 un canal PWM con frecuencia de 50 Hz y resoluci\u00f3n de 12 bits. Se us\u00f3 la funci\u00f3n <code>map()</code> para convertir grados (0\u00b0 a 180\u00b0) en valores de duty cycle entre 205 y 410, que corresponden al rango de operaci\u00f3n del servo.</li> </ul>"},{"location":"Motor/#programacion","title":"\ud83e\udde0 Programaci\u00f3n","text":"<ul> <li>Cambio de giro: Alterna los pines <code>in1</code> e <code>in2</code> para cambiar la direcci\u00f3n del motor.  </li> <li>Velocidad progresiva: Usa <code>ledcWrite()</code> para aumentar gradualmente la velocidad del motor en pasos del 20%.  </li> <li>Servo motor: Utiliza PWM de 12 bits para mover el servo a posiciones espec\u00edficas (0\u00b0, 90\u00b0, 180\u00b0), mostrando los valores en el monitor serial.</li> </ul>"},{"location":"Motor/#resultados-y-observaciones","title":"\ud83d\udcc8 Resultados y Observaciones","text":"<p>El motor DC respondi\u00f3 correctamente al cambio de giro, alternando entre avance y retroceso. El control de velocidad fue progresivo y estable, mostrando c\u00f3mo el PWM puede modificar la potencia entregada al motor. El servo motor se posicion\u00f3 con precisi\u00f3n en los \u00e1ngulos programados, y los valores de duty cycle se reflejaron correctamente en el monitor serial. No se presentaron errores de conexi\u00f3n ni fallas en la ejecuci\u00f3n de los c\u00f3digos.</p>"},{"location":"Motor/#reflexiones-finales","title":"\ud83e\udde9 Reflexiones Finales","text":"<p>Esta pr\u00e1ctica permiti\u00f3 comprender tres aspectos fundamentales del control de motores con ESP32: direcci\u00f3n, velocidad y posici\u00f3n. Se reforz\u00f3 el uso de PWM en diferentes resoluciones y frecuencias, y se evidenci\u00f3 c\u00f3mo la programaci\u00f3n puede traducirse en movimientos f\u00edsicos precisos. Adem\u00e1s, se aprendi\u00f3 a mapear valores para controlar servos, y se observ\u00f3 la importancia de los retardos (<code>delay</code>) para estabilizar los cambios.</p>"},{"location":"Motor/#codigo-direccion-basica","title":"Codigo Direccion Basica","text":"<pre><code>/*Control de 1 solo motor*/\n#define in1 27\n#define in2 14\n\nvoid setup() {\n  /*Declarar Pines Como salida*/\n  pinMode(in1, OUTPUT);\n  pinMode(in2, OUTPUT);\n}\n\nvoid loop() {\n  /*ADELANTE*/\n  digitalWrite(in1, 0);\n  digitalWrite(in2, 1);\n  delay(1000);\n  /*ALTO*/\n  digitalWrite(in1, 0);\n  digitalWrite(in2, 0);\n  delay(1000);\n  /*ATRAS*/\n  digitalWrite(in1, 1);\n  digitalWrite(in2, 0);\n  delay(1000);\n  /*ALTO*/\n  digitalWrite(in1, 0);\n  digitalWrite(in2, 0);\n  delay(1000);\n}\n</code></pre>"},{"location":"Motor/#codigo-control-de-velocidad","title":"Codigo Control de velocidad","text":"<pre><code>/*Control de 1 solo motor*/\n#define in1 27\n#define in2 14\n\nvoid setup() {\n  /*Declarar Pines Como salida*/\n  pinMode(in1, OUTPUT);\n  pinMode(in2, OUTPUT);\n}\n\nvoid loop() {\n  /*ADELANTE*/\n  digitalWrite(in1, 0);\n  digitalWrite(in2, 1);\n  delay(1000);\n  /*ALTO*/\n  digitalWrite(in1, 0);\n  digitalWrite(in2, 0);\n  delay(1000);\n  /*ATRAS*/\n  digitalWrite(in1, 1);\n  digitalWrite(in2, 0);\n  delay(1000);\n  /*ALTO*/\n  digitalWrite(in1, 0);\n  digitalWrite(in2, 0);\n  delay(1000);\n}\n</code></pre>"},{"location":"Motor/#codigo-control-de-servo","title":"Codigo Control de Servo","text":"<pre><code>/*Control de 1 solo motor*/\n#define pwm 12 //Definicion de pin de Velocidad\nint duty = 0;\nint grados = 0;\nvoid setup() {\n  /*Declarar Pines Como salida*/\n  pinMode(in1, OUTPUT);\n  pinMode(in2, OUTPUT);\n  /*Configuracion de pin PWM \n    - Se conecta al pin 12(pwm)\n    - Frecuencia de 50hz\n    - Resolucion de 12 bit (0-4096)\n    - Canal 0\n  */\n  ledcAttachChannel(pwm, 50, 12, 0);\n  Serial.begin(115200);\n}\n\nvoid loop() { \n  /*\n  Servo trabaja del ~5% al ~10% del total\n  ~5% - 0\u00b0\n  ~10% - 180\u00b0\n  5% de 4096 = 204.8\n  10% de 4096 = 409.6\n  */\n  grados=0;\n  duty= map(grados, 0, 180, 205, 410);\n  Serial.print(\"Pos: \");\n  Serial.println(duty);\n  ledcWrite(pwm, duty);\n  delay(1000);\n  grados=90;\n  duty= map(grados, 0, 180, 205, 410);\n  Serial.print(\"Pos: \");\n  Serial.println(duty);\n  ledcWrite(pwm, duty);\n  delay(1000);\n  grados=180;\n  duty= map(grados, 0, 180, 205, 410);\n  Serial.print(\"Pos: \");\n  Serial.println(duty);\n  ledcWrite(pwm, duty);\n  delay(1000);\n}\n</code></pre>"},{"location":"Motor/#evidencias","title":"\ud83d\udcf9 Evidencias","text":"<p>Evidencias en video aqu\u00ed.</p>"},{"location":"Vehiculo/","title":"\ud83d\ude97 Veh\u00edculo Controlado por Bluetooth con Motores DC","text":""},{"location":"Vehiculo/#proposito","title":"\ud83c\udfaf Prop\u00f3sito","text":"<p>Este proyecto consisti\u00f3 en el dise\u00f1o y construcci\u00f3n de un veh\u00edculo a control remoto, utilizando motores de corriente directa (DC), un puente H para el control de direcci\u00f3n, y un microcontrolador ESP32 para la comunicaci\u00f3n v\u00eda Bluetooth. El objetivo principal fue aplicar conocimientos b\u00e1sicos de electr\u00f3nica, mec\u00e1nica y programaci\u00f3n para competir en una din\u00e1mica de rob\u00f3tica.</p>"},{"location":"Vehiculo/#metas-del-proyecto","title":"\ud83e\udded Metas del Proyecto","text":"<p>Meta General: Desarrollar un prototipo funcional de un coche a control remoto que pueda participar en una competencia de rob\u00f3tica, demostrando habilidades de dise\u00f1o, integraci\u00f3n de sistemas y trabajo en equipo.</p> <p>Metas Espec\u00edficas: - Implementar un sistema de control que permita maniobrar el veh\u00edculo con precisi\u00f3n y velocidad. - Dise\u00f1ar una pala frontal que facilite la interacci\u00f3n con objetos (como pelotas) durante la competencia. - Optimizar el rendimiento del coche para lograr una ventaja competitiva en el juego.</p>"},{"location":"Vehiculo/#alcance-del-proyecto","title":"\ud83d\udcd0 Alcance del Proyecto","text":"<p>El proyecto abarc\u00f3 desde la conceptualizaci\u00f3n del dise\u00f1o hasta la implementaci\u00f3n completa del sistema electr\u00f3nico y mec\u00e1nico. Se trabaj\u00f3 con materiales accesibles y se estableci\u00f3 un l\u00edmite de dos semanas para su desarrollo.</p> <p>Incluye: - Dise\u00f1o estructural del veh\u00edculo - Integraci\u00f3n de componentes electr\u00f3nicos - Programaci\u00f3n del sistema de control - Pruebas funcionales previas a la competencia</p>"},{"location":"Vehiculo/#proceso-del-trabajo","title":"\ud83d\udd04 Proceso del Trabajo","text":""},{"location":"Vehiculo/#organizacion-del-equipo","title":"\ud83d\udc65 Organizaci\u00f3n del Equipo","text":"<p>El equipo se dividi\u00f3 en dos \u00e1reas principales: - Desarrollo del c\u00f3digo de programaci\u00f3n - Desarrollo electr\u00f3nico - Dise\u00f1o</p> <p>Mientras algunos miembros se encargaron de la estructura del coche, otros se enfocaron en la programaci\u00f3n y conexiones.</p>"},{"location":"Vehiculo/#materiales-utilizados","title":"\ud83e\uddf0 Materiales Utilizados","text":"<ul> <li>2 motores DC  </li> <li>Puente H  </li> <li>ESP32  </li> <li>Protoboard  </li> <li>Jumpers  </li> <li>LED  </li> <li>Bater\u00eda de 9V  </li> <li>MDF para la base  </li> <li>PLA para impresi\u00f3n 3D de la pala frontal</li> </ul>"},{"location":"Vehiculo/#tecnologias-utilizadas","title":"\ud83e\uddea Tecnolog\u00edas Utilizadas","text":"<ul> <li>Lenguajes: Python, C++  </li> <li>Hardware: ESP32, Arduino  </li> <li>Software: SolidWorks, PSeInt  </li> <li>Otros: CircuitVerse</li> </ul>"},{"location":"Vehiculo/#sistema-electronico","title":"\u26a1 Sistema Electr\u00f3nico","text":"<ul> <li>Se conectaron los motores al puente H, asegurando una correcta polaridad y conexi\u00f3n a tierra.  </li> <li>Los pines IN1 a IN4 se configuraron para controlar la direcci\u00f3n de giro de los motores.  </li> <li>La ESP32 se integr\u00f3 como unidad de control, con especial atenci\u00f3n a la asignaci\u00f3n de pines y la protecci\u00f3n contra cortocircuitos.</li> </ul>"},{"location":"Vehiculo/#programacion","title":"\ud83e\udde0 Programaci\u00f3n","text":"<p>Se desarroll\u00f3 un programa en Arduino IDE que permite controlar el coche mediante una aplicaci\u00f3n Bluetooth.</p> <p>Funciones principales: - Avanzar - Retroceder - Girar a la izquierda/derecha - Detenerse - Ajustar velocidad mediante PWM  </p> <p>La l\u00f3gica de movimiento se bas\u00f3 en la manipulaci\u00f3n de los motores: por ejemplo, para girar, se detiene una rueda mientras la otra sigue girando. El c\u00f3digo para controlar el coche se encuentra al final del art\u00edculo.</p>"},{"location":"Vehiculo/#resultados-y-observaciones","title":"\ud83d\udcc8 Resultados y Observaciones","text":"<p>Antes de la competencia, el coche mostr\u00f3 un buen desempe\u00f1o: - Respond\u00eda a los comandos - La pala funcionaba correctamente - El dise\u00f1o era estable  </p> <p>Durante el evento surgieron algunos inconvenientes: - Uno de los motores se desprendi\u00f3 tras un choque con una silla - El control Bluetooth presentaba cierto retraso en la respuesta - Los movimientos eran algo bruscos, lo que dificultaba la precisi\u00f3n  </p> <p>A pesar de estos detalles, el coche cumpli\u00f3 con los objetivos t\u00e9cnicos del proyecto.</p>"},{"location":"Vehiculo/#reflexiones-finales","title":"\ud83e\udde9 Reflexiones Finales","text":"<p>El proyecto fue una excelente oportunidad para aplicar conocimientos te\u00f3ricos en un entorno pr\u00e1ctico. Se logr\u00f3 integrar electr\u00f3nica, mec\u00e1nica y programaci\u00f3n en un sistema funcional.</p> <p>\u00c1reas de mejora identificadas: - Realizar m\u00e1s pruebas antes de la competencia - Mejorar el montaje de los motores - Optimizar el control desde la app  </p> <p>Esta experiencia reforz\u00f3 la importancia de la planificaci\u00f3n, el trabajo colaborativo y la iteraci\u00f3n constante para lograr un producto funcional y competitivo.</p>"},{"location":"Vehiculo/#codigo-para-controlar-el-coche","title":"Codigo para controlar el coche","text":"<pre><code>#include \"BluetoothSerial.h\"\n\nBluetoothSerial SerialBT;\n\n// Pines del puente H\nconst int IN1 = 12; // Motor izquierdo\nconst int IN2 = 11;\nconst int ENA = 13;\nconst int IN3 = 10; // Motor derecho\nconst int IN4 = 9;\nconst int ENB = 7;\n\nint valSpeed = 255;\n\nvoid setup() {\n  Serial.begin(115200);\n  SerialBT.begin(\"CarroESP32\"); // Nombre del dispositivo Bluetooth\n\n  pinMode(IN1, OUTPUT);\n  pinMode(IN2, OUTPUT);\n  pinMode(ENA, OUTPUT);\n  pinMode(IN3, OUTPUT);\n  pinMode(IN4, OUTPUT);\n  pinMode(ENB, OUTPUT);\n\n  stopMotors();\n}\n\nvoid loop() {\n  if (SerialBT.available()) {\n    char command = SerialBT.read();\n    Serial.println(command);\n\n    switch (command) {\n      case 'F': forward(); break;\n      case 'B': backward(); break;\n      case 'L': turnLeft(); break;\n      case 'R': turnRight(); break;\n      case 'S': stopMotors(); break;\n      case '0': setSpeed(0); break;\n      case '1': setSpeed(25); break;\n      case '2': setSpeed(50); break;\n      case '3': setSpeed(75); break;\n      case '4': setSpeed(100); break;\n      case '5': setSpeed(125); break;\n      case '6': setSpeed(150); break;\n      case '7': setSpeed(175); break;\n      case '8': setSpeed(200); break;\n      case '9': setSpeed(255); break;\n    }\n  }\n}\n\nvoid forward() {\n  analogWrite(ENA, valSpeed);\n  analogWrite(ENB, valSpeed);\n  digitalWrite(IN1, HIGH);\n  digitalWrite(IN2, LOW);\n  digitalWrite(IN3, HIGH);\n  digitalWrite(IN4, LOW);\n}\n\nvoid backward() {\n  analogWrite(ENA, valSpeed);\n  analogWrite(ENB, valSpeed);\n  digitalWrite(IN1, LOW);\n  digitalWrite(IN2, HIGH);\n  digitalWrite(IN3, LOW);\n  digitalWrite(IN4, HIGH);\n}\n\nvoid turnLeft() {\n  analogWrite(ENA, valSpeed / 2);\n  analogWrite(ENB, valSpeed);\n  digitalWrite(IN1, HIGH);\n  digitalWrite(IN2, LOW);\n  digitalWrite(IN3, HIGH);\n  digitalWrite(IN4, LOW);\n}\n\nvoid turnRight() {\n  analogWrite(ENA, valSpeed);\n  analogWrite(ENB, valSpeed / 2);\n  digitalWrite(IN1, HIGH);\n  digitalWrite(IN2, LOW);\n  digitalWrite(IN3, HIGH);\n  digitalWrite(IN4, LOW);\n}\n\nvoid stopMotors() {\n  analogWrite(ENA, 0);\n  analogWrite(ENB, 0);\n  digitalWrite(IN1, LOW);\n  digitalWrite(IN2, LOW);\n  digitalWrite(IN3, LOW);\n  digitalWrite(IN4, LOW);\n}\n\nvoid setSpeed(int val) {\n  valSpeed = val;\n}\n</code></pre>"},{"location":"Vehiculo/#evidencias","title":"\ud83d\udcf9 Evidencias","text":"<p>Evidencias en video aqu\u00ed.</p>"},{"location":"balansa/BalsaStewart/","title":"Plataforma Stewart - An\u00e1lisis Completo","text":""},{"location":"balansa/BalsaStewart/#1-objetivo-del-sistema","title":"1. Objetivo del sistema","text":"<p>El sistema busca mantener una pelota roja en el centro de un plato circular montado sobre una plataforma tipo Stewart con 3 servos distribuidos a 120\u00b0. La c\u00e1mara detecta plato y pelota; el c\u00f3digo en Python calcula la inclinaci\u00f3n necesaria mediante PID y cinem\u00e1tica inversa; el ESP32 ejecuta los \u00e1ngulos recibidos y mueve los servos.</p> <p>En la interfaz principal (Deteccion_final.jpg) se observa:</p> <p></p> <p>Se ve: - Plato detectado (borde verde). - Centro del plato con c\u00edrculo amarillo/naranja y zona muerta. - Pelota roja con l\u00ednea azul hacia el centro. - HUD con <code>Kp, Ki, Kd</code>, rangos de \u00e1ngulos, \u00e1ngulos actuales y errores normalizados.</p>"},{"location":"balansa/BalsaStewart/#2-deteccion-del-plato-houghcircles-y-mascara-circular","title":"2. Detecci\u00f3n del plato (HoughCircles) y m\u00e1scara circular","text":"<p>El plato se detecta con <code>cv2.HoughCircles</code> sobre una imagen en escalar de grises suavizada:</p> <ul> <li>Conversi\u00f3n y suavizado:</li> <li><code>gray = cv2.cvtColor(frame, cv2.COLOR_BGR2GRAY)</code></li> <li> <p><code>blurred = cv2.GaussianBlur(gray, (5,5), 0)</code></p> </li> <li> <p>Par\u00e1metros Hough:</p> </li> <li><code>dp = 0.8</code>: el acumulador de Hough tiene 80% de la resoluci\u00f3n, buena precisi\u00f3n sin ser tan pesado.</li> <li><code>minDist = 280</code>: asegura que solo se detecte un c\u00edrculo grande, evita dobles detecciones.</li> <li><code>param1 = 165</code>: umbral alto de Canny, solo se usan bordes muy definidos (borde del plato).</li> <li><code>param2 = 15</code>: votos m\u00ednimos en el acumulador; bajar este valor hace que aparezcan muchos falsos c\u00edrculos, subirlo hace que deje de detectar.</li> <li><code>minRadius = 130</code>, <code>maxRadius = 211</code>: rango de radios aproximado para el plato.</li> </ul> <p>Se elige el c\u00edrculo de mayor radio de la lista de candidatos; si hay ruido o sombras, estos par\u00e1metros hacen que aun as\u00ed el borde m\u00e1s grande sea el del plato.</p> <p>Para que el c\u00edrculo no \u201csalte\u201d entre cuadros, se aplica un filtro exponencial:</p> <ul> <li><code>plato_cx_f = \u03b1*plato_cx + (1-\u03b1)*plato_cx_f</code> con <code>\u03b1 = 0.9</code>.</li> <li>Esto significa 90% de nuevo valor, 10% de historia; la posici\u00f3n se suaviza pero responde r\u00e1pido.</li> </ul> <p>Con el centro y radio filtrados se genera la m\u00e1scara circular:</p> <ul> <li>M\u00e1scara en blanco y negro del tama\u00f1o del frame, con un c\u00edrculo blanco en la zona del plato y el resto negro.</li> <li>Se usa <code>cv2.bitwise_and</code> para dejar negro todo lo que est\u00e9 fuera del plato; esto garantiza que la detecci\u00f3n de la pelota se haga solo sobre el \u00e1rea \u00fatil.</li> </ul> <p>Se dibujan dos c\u00edrculos:</p> <ul> <li>Uno con radio <code>plato_r_f</code> (borde verde).</li> <li>Uno interno con radio peque\u00f1o, la zona muerta del centro (amarillo/naranja); si la pelota cae dentro, el sistema no corrige para no oscilar.</li> </ul>"},{"location":"balansa/BalsaStewart/#3-deteccion-de-la-pelota-roja-y-calculo-del-error","title":"3. Detecci\u00f3n de la pelota roja y c\u00e1lculo del error","text":"<p>Con el frame enmascarado, se detecta el color rojo usando espacio HSV:</p> <ul> <li>Se definen dos rangos de rojo:</li> <li><code>[0, 150, 50]</code> a <code>[8, 255, 255]</code> (rojo bajo).</li> <li><code>[170, 150, 50]</code> a <code>[179, 255, 255]</code> (rojo alto).</li> <li>Se hace <code>inRange</code> para cada rango y luego se suman las m\u00e1scaras.</li> </ul> <p>Para reducir ruido:</p> <ul> <li>Se aplica una apertura morfol\u00f3gica (OPEN) con kernel el\u00edptico 5x5 que elimina peque\u00f1as manchas blancas.</li> <li>Se aplica cierre (CLOSE) con el mismo kernel para unir huecos dentro de la mancha de la pelota.</li> </ul> <p>Posteriormente:</p> <ul> <li>Se buscan contornos y se filtran por \u00e1rea (por ejemplo, entre 100 y 5000 p\u00edxeles).</li> <li>De los contornos v\u00e1lidos se escoge el de mayor \u00e1rea como la pelota.</li> <li>Se calculan los momentos de ese contorno y su centroide <code>(cx, cy)</code>.</li> </ul> <p>El error en p\u00edxeles se define como:</p> <ul> <li><code>errX_raw = cx - plato_cx_f</code> (positivo si la pelota est\u00e1 a la derecha).</li> <li><code>errY_raw = cy - plato_cy_f</code> (positivo si la pelota est\u00e1 hacia abajo).</li> </ul> <p>Para que el error sea independiente del tama\u00f1o f\u00edsico del plato:</p> <ul> <li>Se divide por el radio filtrado <code>plato_r_f</code>, obteniendo:</li> <li><code>errX_norm = errX_raw / plato_r_f</code>.</li> <li><code>errY_norm = errY_raw / plato_r_f</code>.</li> <li>Esto produce un error normalizado en el rango aproximado <code>[-1, +1]</code>, donde 1 significa que la pelota est\u00e1 al borde del plato en una direcci\u00f3n dada.</li> </ul> <p>Estos errores normalizados se filtran suavemente:</p> <ul> <li><code>errX_f = \u03b1_err*errX_norm + (1-\u03b1_err)*errX_f</code> con <code>\u03b1_err = 0.6</code>.</li> <li>El error filtrado reacciona r\u00e1pido a cambios pero sin a\u00f1adir demasiado ruido al PID.</li> </ul> <p>Si la pelota sale del plato o ya no se detecta:</p> <ul> <li>El error se pone a cero.</li> <li>Se resetean las integrales y errores previos del PID para evitar windup (acumulaci\u00f3n excesiva de integral).</li> </ul>"},{"location":"balansa/BalsaStewart/#4-control-pid-y-zona-muerta","title":"4. Control PID y zona muerta","text":"<p>Cada eje (X e Y) utiliza un PID discreto con ganancia ajustable en tiempo real mediante los slicers de la ventana \u201cPID Tuner\u201d (<code>Slicer_PID.jpg</code>):</p> <p></p> <p>En el loop:</p> <ul> <li>Se leen los valores de tres trackbars:</li> <li><code>\"Kp x10\"</code> \u2192 <code>Kp = slider / 10.0</code>.</li> <li><code>\"Ki x100\"</code> \u2192 <code>Ki = slider / 100.0</code>.</li> <li><code>\"Kd x10\"</code> \u2192 <code>Kd = slider / 10.0</code>.</li> <li>Estos se asignan a <code>pid_x</code> y <code>pid_y</code>, por lo que se puede afinar el controlador sin recompilar.</li> </ul> <p>El PID calcula:</p> <ul> <li><code>output = Kp*e + Ki*integral + Kd*derivative</code> con:</li> <li>Anti-windup: la integral est\u00e1 limitada a un rango como <code>[-50, 50]</code>.</li> <li>Saturaci\u00f3n de la salida: por ejemplo, <code>[-20, +20]</code> grados de inclinaci\u00f3n m\u00e1ximos.</li> </ul> <p>La entrada al PID no es el error normalizado directo, sino escalado:</p> <ul> <li><code>errX_input = errX_f * 100</code>.</li> <li><code>errY_input = errY_f * 100</code>.</li> </ul> <p>Se implementa una zona muerta de error (<code>DEADZONE_ERR_INPUT</code>):</p> <ul> <li>Si <code>abs(errX_input) &lt; DEADZONE_ERR_INPUT</code>, se fuerza <code>errX_input = 0</code>.</li> <li>Esto evita que peque\u00f1as variaciones aleatorias causen correcciones continuas y vibraciones en los servos.</li> </ul> <p>Salida corregida:</p> <ul> <li><code>theta_X = -pid_x.update(errX_input)</code>.</li> <li><code>theta_Y = -pid_y.update(errY_input)</code>.</li> </ul> <p>El signo negativo es clave: el PID ve el error positivo, pero la inclinaci\u00f3n debe ser hacia el lado contrario para que la pelota ruede de vuelta al centro.</p> <p>Finalmente, <code>theta_X</code> y <code>theta_Y</code> se limitan a un rango razonable, por ejemplo <code>[-25, +25]</code> grados.</p>"},{"location":"balansa/BalsaStewart/#5-cinematica-inversa-de-3-servos-120","title":"5. Cinem\u00e1tica inversa de 3 servos (120\u00b0)","text":"<p>Los tres servos est\u00e1n colocados equidistantes en la base, cada uno separado 120\u00b0 del siguiente. La inclinaci\u00f3n en X e Y de la plataforma se transforma en \u00e1ngulos finales <code>A1</code>, <code>A2</code>, <code>A3</code> de cada servo usando trigonometr\u00eda:</p> <p>Se define un \u00e1ngulo base fijo:</p> <ul> <li><code>BASE_ANGLE</code> (por ejemplo, 50\u00b0) es la posici\u00f3n neutra, donde la plataforma est\u00e1 lo m\u00e1s nivelada posible.</li> <li><code>MIN_ANGLE</code> y <code>MAX_ANGLE</code> definen l\u00edmites duros (como 36\u00b0 y 63\u00b0 en <code>Slicer_grados.jpg</code>).</li> </ul> <p>En la funci\u00f3n de cinem\u00e1tica:</p> <pre><code>angle_1 = BASE_ANGLE + theta_Y\nangle_2 = BASE_ANGLE + (theta_Xcos(30\u00b0)) - (theta_Ysin(30\u00b0))\nangle_3 = BASE_ANGLE - (theta_Xcos(30\u00b0)) - (theta_Ysin(30\u00b0))\n</code></pre> <ul> <li><code>cos(30\u00b0) \u2248 0.866</code>, <code>sin(30\u00b0) = 0.5</code>.</li> <li><code>angle_1</code> responde m\u00e1s a inclinaci\u00f3n en Y (servo \u201cfrontal\u201d).</li> <li><code>angle_2</code> y <code>angle_3</code> combinan X e Y debido a la simetr\u00eda de 120\u00b0.</li> </ul> <p>Despu\u00e9s se hace <code>clip</code> de cada \u00e1ngulo entre <code>MIN_ANGLE</code> y <code>MAX_ANGLE</code>:</p> <ul> <li>As\u00ed el sistema no pide nunca un \u00e1ngulo mec\u00e1nicamente imposible para los servos.</li> </ul> <p>Las posiciones calculadas se mandan al ESP32 como:</p> <pre><code>A1:\u00e1ngulo1,A2:\u00e1ngulo2,A3:\u00e1ngulo3\\n\n</code></pre> <p>El ESP32 interpreta este string, convierte a PWM y actualiza los tres servos.</p> <p>En la ventana \u201cServo Angles\u201d (<code>Slicer_grados.jpg</code>) se pueden ajustar en vivo <code>Base</code>, <code>Min</code> y <code>Max</code>:</p> <p></p> <p>El c\u00f3digo chequea constantemente:</p> <ul> <li>Si <code>Min &gt;= Max</code>, sube <code>Max</code> autom\u00e1ticamente.</li> <li>Si <code>Base</code> sale del rango <code>[Min, Max]</code>, se corrige y se actualiza el slider.</li> </ul> <p>Cada cambio dispara el env\u00edo de una nueva configuraci\u00f3n al ESP32:</p> <pre><code>CFG:BASE:Base,MIN:Min,MAX:Max\\n\n</code></pre>"},{"location":"balansa/BalsaStewart/#6-trackbars-y-ajuste-en-tiempo-real","title":"6. Trackbars y ajuste en tiempo real","text":"<p>Las ventanas de PID y \u00e1ngulos non solo muestran sliders, sino paneles informativos generados con im\u00e1genes:</p> <ul> <li>Para PID (<code>Slicer_PID.jpg</code>): se dibuja fondo gris y texto grande \u201cKp = xx.xx, Ki = yy.yyy, Kd = zz.zz\u201d.</li> <li>Para \u00e1ngulos (<code>Slicer_grados.jpg</code>): se dibuja texto \u201cBase = 50.0 grados, Min = 36.0 grados, Max = 63.0 grados\u201d.</li> </ul> <p>De esta forma, aunque los sliders est\u00e9n arriba, el usuario ve los valores num\u00e9ricos exactos con decimales.</p>"},{"location":"balansa/BalsaStewart/#7-piezas-mecanicas-e-impresion-3d","title":"7. Piezas mec\u00e1nicas e impresi\u00f3n 3D","text":"<p>El dise\u00f1o mec\u00e1nico se basa en piezas modeladas en CAD y exportadas a STL. Se muestran varias vistas de las piezas y configuraciones de impresora, por ejemplo:</p> <ul> <li><code>Pieza_1.jpg</code>: muestra un lote de piezas peque\u00f1as (como uniones o brazos cortos) sobre la cama de impresi\u00f3n, con par\u00e1metros de capa y tiempo de impresi\u00f3n.</li> <li><code>Union_2.jpg</code>: otra pieza de uni\u00f3n m\u00e1s larga, tambi\u00e9n en Orca/Bambu Studio, donde se ve altura de capa, anchos de l\u00ednea y tiempo total.</li> <li><code>Base_servos.jpg</code>: representa la base donde se atornillan los servos, con soportes generados solo en algunas zonas verdes.</li> <li><code>Base_superior.jpg</code>: anillo o tapa superior de la plataforma, tambi\u00e9n con soportes definidos y estimaci\u00f3n de tiempo y peso de material.</li> </ul> <p>Ejemplo de c\u00f3mo documentarlas en la nota:</p> <p>  ```</p>"},{"location":"balansa/BalsaStewart/#8-codigo-completo","title":"8. Codigo completo","text":"<pre><code>import cv2\nimport numpy as np\nimport math\nimport serial\nimport time\n\n\n# ===================== CONFIGURACION SERIAL =====================\nPUERTO_SERIAL = 'COM11' # &lt;-- AJUSTA ESTO AL PUERTO DE TU ESP32\nBAUDRATE = 115200\nTIMEOUT = 0.01\n\n\ntry:\n    arduino = serial.Serial(PUERTO_SERIAL, BAUDRATE, timeout=TIMEOUT)\n    time.sleep(2)\n    print(\"\u2713 Serial conectado en\", PUERTO_SERIAL)\nexcept Exception as e:\n    print(f\"\u2717 ERROR: No se pudo conectar en {PUERTO_SERIAL}. {e}\")\n    arduino = None\n\n# ===================== PARAMETROS HOUGH (PLATO) =====================\ndp       = 0.8\nminDist  = 280\nparam1   = 165\nparam2   = 15\nminRadius = 130\nmaxRadius = 211\n\n\n# ===================== FILTRO EXPONENCIAL DEL PLATO =====================\nalpha_plato = 0.9 \nplato_cx_f = plato_cy_f = plato_r_f = None \n\n\n# ===================== COEFICIENTES DE SUAVIZADO DE ERROR =====================\nalpha_err = 0.6\nerrX_f = errY_f = 0.0 \n\n\n# ===================== VIDEO =====================\ncap = cv2.VideoCapture(0)\ncap.set(cv2.CAP_PROP_FRAME_WIDTH, 640)\ncap.set(cv2.CAP_PROP_FRAME_HEIGHT, 480)\n\n\n# ===================== ANGULOS DE SERVO (INICIALES) =====================\nBASE_ANGLE = 50.0 \nMIN_ANGLE = 30.0  \nMAX_ANGLE = 70.0   \n\n\nCOS_30 = math.cos(math.radians(30)) \nSIN_30 = math.sin(math.radians(30)) \n\n\n# ===================== PID BASICO =====================\nclass PID:\n    def __init__(self, Kp, Ki, Kd, setpoint=0, dt=0.03):\n        self.Kp = Kp\n        self.Ki = Ki\n        self.Kd = Kd\n        self.setpoint = setpoint\n        self.dt = dt\n        self.prev_error = 0\n        self.integral = 0\n\n\n    def update(self, measurement):\n        error = self.setpoint - measurement\n        self.integral += error * self.dt\n        self.integral = np.clip(self.integral, -50, 50) \n        derivative = (error - self.prev_error) / self.dt\n\n        output = self.Kp * error + self.Ki * self.integral + self.Kd * derivative\n\n        output = np.clip(output, -20, 20)\n        self.prev_error = error\n        return output\n\n\n# Inicializar PIDs de inclinaci\u00f3n\npid_dt = 0.03 \npid_x = PID(Kp=10.0, Ki=0.2, Kd=1.0, dt=pid_dt) \npid_y = PID(Kp=10.0, Ki=0.2, Kd=1.0, dt=pid_dt)\n\n\n# ===================== CINEM\u00c1TICA DE 3 SERVOS =====================\ndef calcular_angulos_servos(theta_x, theta_y, base_angle, min_angle, max_angle):\n    angle_1 = base_angle + theta_y \n    angle_2 = base_angle + (theta_x * COS_30) - (theta_y * SIN_30)\n    angle_3 = base_angle - (theta_x * COS_30) - (theta_y * SIN_30)\n\n    angle_1 = np.clip(angle_1, min_angle, max_angle)\n    angle_2 = np.clip(angle_2, min_angle, max_angle)\n    angle_3 = np.clip(angle_3, min_angle, max_angle)\n\n    return int(angle_1), int(angle_2), int(angle_3)\n\n\n# ===================== ENVIO DE CONFIGURACION AL ESP32 =====================\ndef enviar_config_angulos(base, min_ang, max_ang):\n    \"\"\"Env\u00eda la configuraci\u00f3n de \u00e1ngulos al ESP32\"\"\"\n    if arduino is not None:\n        try:\n            comando_config = f\"CFG:BASE:{base},MIN:{min_ang},MAX:{max_ang}\\n\"\n            arduino.write(comando_config.encode('ascii'))\n            print(f\"\u2713 Config enviada: BASE={base}\u00b0, MIN={min_ang}\u00b0, MAX={max_ang}\u00b0\")\n        except Exception as e:\n            print(f\"Error al enviar config: {e}\")\n\n\n# ===================== CONFIGURACI\u00d3N DE TRACKBARS =====================\ndef on_trackbar(val):\n    pass\n\n\n# Funci\u00f3n para crear imagen de informaci\u00f3n con valores reales\ndef crear_imagen_info_pid(kp, ki, kd):\n    img = np.zeros((150, 400, 3), dtype=np.uint8)\n    img[:] = (40, 40, 40)  # Fondo gris oscuro\n\n    font = cv2.FONT_HERSHEY_SIMPLEX\n    cv2.putText(img, \"VALORES PID ACTUALES\", (70, 30), font, 0.7, (255, 255, 255), 2)\n    cv2.line(img, (20, 40), (380, 40), (100, 100, 100), 1)\n\n    cv2.putText(img, f\"Kp = {kp:.2f}\", (50, 75), font, 0.8, (0, 255, 255), 2)\n    cv2.putText(img, f\"Ki = {ki:.3f}\", (50, 105), font, 0.8, (0, 255, 255), 2)\n    cv2.putText(img, f\"Kd = {kd:.2f}\", (50, 135), font, 0.8, (0, 255, 255), 2)\n\n    return img\n\n\ndef crear_imagen_info_angulos(base, min_ang, max_ang):\n    img = np.zeros((150, 400, 3), dtype=np.uint8)\n    img[:] = (40, 40, 40)  # Fondo gris oscuro\n\n    font = cv2.FONT_HERSHEY_SIMPLEX\n    cv2.putText(img, \"ANGULOS DE SERVOS\", (85, 30), font, 0.7, (255, 255, 255), 2)\n    cv2.line(img, (20, 40), (380, 40), (100, 100, 100), 1)\n\n    cv2.putText(img, f\"Base = {base}.0 grados\", (50, 75), font, 0.7, (255, 165, 0), 2)\n    cv2.putText(img, f\"Min  = {min_ang}.0 grados\", (50, 105), font, 0.7, (255, 165, 0), 2)\n    cv2.putText(img, f\"Max  = {max_ang}.0 grados\", (50, 135), font, 0.7, (255, 165, 0), 2)\n\n    return img\n\n\n# Crear ventana de control PID\ncv2.namedWindow(\"PID Tuner\")\ncv2.resizeWindow(\"PID Tuner\", 400, 150)\n\n# Trackbars PID (sin texto de unidades, se muestra en la imagen)\ncv2.createTrackbar(\"Kp x10\", \"PID Tuner\", int(pid_x.Kp * 10), 500, on_trackbar)\ncv2.createTrackbar(\"Ki x100\", \"PID Tuner\", int(pid_x.Ki * 100), 100, on_trackbar)\ncv2.createTrackbar(\"Kd x10\", \"PID Tuner\", int(pid_x.Kd * 10), 50, on_trackbar)\n\n# Crear ventana de control de \u00c1ngulos\ncv2.namedWindow(\"Servo Angles\")\ncv2.resizeWindow(\"Servo Angles\", 400, 150)\n\n# Trackbars de \u00e1ngulos (0-180 grados)\ncv2.createTrackbar(\"Base\", \"Servo Angles\", int(BASE_ANGLE), 180, on_trackbar)\ncv2.createTrackbar(\"Min\", \"Servo Angles\", int(MIN_ANGLE), 180, on_trackbar)\ncv2.createTrackbar(\"Max\", \"Servo Angles\", int(MAX_ANGLE), 180, on_trackbar)\n\n# Enviar configuraci\u00f3n inicial\nenviar_config_angulos(int(BASE_ANGLE), int(MIN_ANGLE), int(MAX_ANGLE))\n\nprint(\"\ud83c\udfaf Detecci\u00f3n de Plato y Errores de Pelota (Fondo Negro)\")\nprint(\"\ud83d\udcd0 Ajusta los \u00e1ngulos en tiempo real con los sliders\")\nprint(\"Presiona 'q' para salir\")\n\n# Variables para detectar cambios en \u00e1ngulos\nprev_base = int(BASE_ANGLE)\nprev_min = int(MIN_ANGLE)\nprev_max = int(MAX_ANGLE)\n\n# Bucle principal de control\nwhile True:\n    # --- LECTURA Y ACTUALIZACI\u00d3N DEL PID ---\n    kp_val = cv2.getTrackbarPos(\"Kp x10\", \"PID Tuner\") / 10.0\n    ki_val = cv2.getTrackbarPos(\"Ki x100\", \"PID Tuner\") / 100.0\n    kd_val = cv2.getTrackbarPos(\"Kd x10\", \"PID Tuner\") / 10.0\n\n    pid_x.Kp, pid_x.Ki, pid_x.Kd = kp_val, ki_val, kd_val\n    pid_y.Kp, pid_y.Ki, pid_y.Kd = kp_val, ki_val, kd_val\n\n    # --- LECTURA DE \u00c1NGULOS DESDE TRACKBARS ---\n    current_base = cv2.getTrackbarPos(\"Base\", \"Servo Angles\")\n    current_min = cv2.getTrackbarPos(\"Min\", \"Servo Angles\")\n    current_max = cv2.getTrackbarPos(\"Max\", \"Servo Angles\")\n\n    # Mostrar valores reales en las ventanas de trackbars\n    img_pid_info = crear_imagen_info_pid(kp_val, ki_val, kd_val)\n    cv2.imshow(\"PID Tuner\", img_pid_info)\n\n    img_angle_info = crear_imagen_info_angulos(current_base, current_min, current_max)\n    cv2.imshow(\"Servo Angles\", img_angle_info)\n\n    # Validar que Min &lt; Base &lt; Max\n    if current_min &gt;= current_max:\n        current_max = current_min + 1\n        cv2.setTrackbarPos(\"Max\", \"Servo Angles\", current_max)\n\n    if current_base &lt; current_min:\n        current_base = current_min\n        cv2.setTrackbarPos(\"Base\", \"Servo Angles\", current_base)\n    elif current_base &gt; current_max:\n        current_base = current_max\n        cv2.setTrackbarPos(\"Base\", \"Servo Angles\", current_base)\n\n    # Detectar cambios y enviar nueva configuraci\u00f3n\n    if (current_base != prev_base or current_min != prev_min or current_max != prev_max):\n        enviar_config_angulos(current_base, current_min, current_max)\n        prev_base, prev_min, prev_max = current_base, current_min, current_max\n\n    # --- RESTO DE L\u00d3GICA DE VISI\u00d3N Y CONTROL ---\n    ret, frame = cap.read()\n    if not ret:\n        break\n\n    frame = cv2.flip(frame, 1)\n    frame_display = frame.copy() \n\n    # --- 1) DETECCION DEL PLATO (HOUGH) ---\n    gray = cv2.cvtColor(frame, cv2.COLOR_BGR2GRAY)\n    blurred = cv2.GaussianBlur(gray, (5,5), 0)\n    circles = cv2.HoughCircles(\n        blurred, cv2.HOUGH_GRADIENT,\n        dp=dp, minDist=minDist,\n        param1=param1, param2=param2,\n        minRadius=minRadius, maxRadius=maxRadius\n    )\n\n    plato_cx, plato_cy, plato_r = None, None, None\n\n    if circles is not None:\n        circles = np.round(circles[0, :]).astype(\"int\")\n        radios = [r for (_,_,r) in circles]\n        idx = np.argmax(radios)\n        plato_cx, plato_cy, plato_r = circles[idx]\n\n        if plato_cx_f is None:\n            plato_cx_f, plato_cy_f, plato_r_f = plato_cx, plato_cy, plato_r\n        else:\n            plato_cx_f = int(alpha_plato*plato_cx + (1-alpha_plato)*plato_cx_f)\n            plato_cy_f = int(alpha_plato*plato_cy + (1-alpha_plato)*plato_cy_f)\n            plato_r_f  = int(alpha_plato*plato_r + (1-alpha_plato)*plato_r_f)\n\n        cv2.circle(frame_display, (plato_cx_f, plato_cy_f), plato_r_f, (0,255,0), 3)\n        cv2.circle(frame_display, (plato_cx_f, plato_cy_f), 6, (0,255,0), -1) # Centro\n\n        # --- NUEVO C\u00cdRCULO: ZONA MUERTA ---\n        DEADZONE_RADIUS = 10 # Radio en p\u00edxeles para la zona muerta (ajusta si es necesario)\n        cv2.circle(frame_display, (plato_cx_f, plato_cy_f), DEADZONE_RADIUS, (0,165,255), 2)\n\n        cv2.putText(frame_display, f\"PLATO DETECTADO (r={plato_r_f})\", \n                             (plato_cx_f - 120, plato_cy_f - plato_r_f - 10), \n                             cv2.FONT_HERSHEY_SIMPLEX, 0.6, (0,255,0), 2)\n    else:\n        plato_cx_f = plato_cy_f = plato_r_f = None\n        cv2.putText(frame_display, \"PLATO NO DETECTADO\", (10, 30), cv2.FONT_HERSHEY_SIMPLEX, 0.7, (0,0,255), 2)\n\n    # --- A) ENMASCARAMIENTO CIRCULAR (FONDO NEGRO) ---\n    if plato_cx_f is not None:\n        mask_plato = np.zeros(frame.shape[:2], dtype=\"uint8\")\n        cv2.circle(mask_plato, (plato_cx_f, plato_cy_f), plato_r_f - 5, 255, -1) \n        frame_deteccion = cv2.bitwise_and(frame, frame, mask=mask_plato)\n    else:\n        frame_deteccion = frame\n\n    # --- 2) DETECCION PELOTA ROJA (COLOR / CENTROIDE) ---\n    red_low1  = np.array([0, 150, 50], np.uint8)\n    red_high1 = np.array([8, 255, 255], np.uint8)\n    red_low2  = np.array([170, 150, 50], np.uint8)\n    red_high2 = np.array([179, 255, 255], np.uint8)\n\n    hsv = cv2.cvtColor(frame_deteccion, cv2.COLOR_BGR2HSV)\n    mask1 = cv2.inRange(hsv, red_low1, red_high1)\n    mask2 = cv2.inRange(hsv, red_low2, red_high2)\n    mask = cv2.add(mask1, mask2)\n\n    kernel = cv2.getStructuringElement(cv2.MORPH_ELLIPSE, (5,5))\n    mask = cv2.morphologyEx(mask, cv2.MORPH_OPEN, kernel)\n    mask = cv2.morphologyEx(mask, cv2.MORPH_CLOSE, kernel)\n\n    contornos, _ = cv2.findContours(mask, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)\n\n    mejor_c = None\n    mejor_cx = mejor_cy = 0\n    mejor_area = 0\n\n    for c in contornos:\n        area = cv2.contourArea(c)\n        if 100 &lt; area &lt; 5000:\n            M = cv2.moments(c)\n            if M[\"m00\"] != 0:\n                cx = int(M[\"m10\"]/M[\"m00\"])\n                cy = int(M[\"m01\"]/M[\"m00\"])\n\n                if mejor_c is None or area &gt; mejor_area:\n                    mejor_c, mejor_cx, mejor_cy, mejor_area = c, cx, cy, area\n\n    # --- 3) CALCULO Y SUAVIZADO DE ERROR ---\n    errX_raw = 0.0\n    errY_raw = 0.0\n    pelota_detectada = False\n\n    if mejor_c is not None and plato_cx_f is not None:\n        dist_al_centro = math.hypot(mejor_cx - plato_cx_f, mejor_cy - plato_cy_f)\n\n        if dist_al_centro &lt; plato_r_f:\n            pelota_detectada = True\n\n            errX_raw = mejor_cx - plato_cx_f \n            errY_raw = mejor_cy - plato_cy_f \n\n            if plato_r_f &gt; 0:\n                 errX_norm = errX_raw / plato_r_f\n                 errY_norm = errY_raw / plato_r_f\n            else:\n                 errX_norm, errY_norm = 0.0, 0.0\n\n            errX_f = alpha_err * errX_norm + (1-alpha_err) * errX_f\n            errY_f = alpha_err * errY_norm + (1-alpha_err) * errY_f\n\n            cv2.circle(frame_display, (mejor_cx, mejor_cy), 8, (0,0,255), -1)\n            cv2.line(frame_display, (mejor_cx, mejor_cy), (plato_cx_f, plato_cy_f), (255,0,0), 2)\n\n        else:\n            errX_f, errY_f = 0.0, 0.0\n            # RESETEAR PID cuando no hay pelota\n            pid_x.integral = 0.0\n            pid_y.integral = 0.0\n            pid_x.prev_error = 0.0\n            pid_y.prev_error = 0.0\n    else:\n        errX_f, errY_f = 0.0, 0.0\n        # RESETEAR PID cuando no hay pelota\n        pid_x.integral = 0.0\n        pid_y.integral = 0.0\n        pid_x.prev_error = 0.0\n        pid_y.prev_error = 0.0\n\n    # --- 4) CONTROL PID Y ENV\u00cdO SERIAL (\ud83c\udfaf L\u00d3GICA CORREGIDA) ---\n    errX_input = errX_f * 100\n    errY_input = errY_f * 100\n\n    # Zona muerta para estabilidad\n    DEADZONE_ERR_INPUT = 5.0\n    if abs(errX_input) &lt; DEADZONE_ERR_INPUT:\n        errX_input = 0.0\n    if abs(errY_input) &lt; DEADZONE_ERR_INPUT:\n        errY_input = 0.0\n\n    # \ud83c\udfaf CORRECCI\u00d3N CLAVE: INVERTIR SE\u00d1AL DE CONTROL\n    theta_X = -pid_x.update(errX_input)  # \u2190 NEGATIVO: COMPENSA el error\n    theta_Y = -pid_y.update(errY_input)  # \u2190 NEGATIVO: COMPENSA el error\n\n    # Limitar inclinaciones extremas\n    theta_X = np.clip(theta_X, -25, 25)\n    theta_Y = np.clip(theta_Y, -25, 25)\n\n    A1, A2, A3 = calcular_angulos_servos(theta_X, theta_Y, current_base, current_min, current_max)\n\n    comando = f\"A1:{A1},A2:{A2},A3:{A3}\\n\"\n\n    if arduino is not None:\n        try:\n            arduino.write(comando.encode('ascii'))\n        except Exception as e:\n            print(f\"Error al enviar datos: {e}\")\n\n    # --- 5) HUD FINAL ---\n    font = cv2.FONT_HERSHEY_SIMPLEX\n\n    cv2.putText(frame_display, f\"Kp:{kp_val:.1f} Ki:{ki_val:.2f} Kd:{kd_val:.1f}\", \n                (10, frame_display.shape[0]-120), font, 0.5, (255,255,0), 2)\n\n    cv2.putText(frame_display, f\"Base:{current_base} Min:{current_min} Max:{current_max}\", \n                (10, frame_display.shape[0]-95), font, 0.5, (255,165,0), 2)\n\n    cv2.putText(frame_display, f\"Angulos: A1:{A1} A2:{A2} A3:{A3}\", \n                (10, frame_display.shape[0]-70), font, 0.5, (255,255,0), 2)\n\n    if pelota_detectada:\n        cv2.putText(frame_display, \n                    f'Inclinacion X,Y: ({theta_X:+.1f} deg, {theta_Y:+.1f} deg)', \n                    (10, frame_display.shape[0]-45), font, 0.5, (0,255,0), 2)\n        cv2.putText(frame_display, \n                    f'Error Norm X,Y: ({errX_f:+.2f}, {errY_f:+.2f})', \n                    (10, frame_display.shape[0]-20), font, 0.5, (0,255,255), 2)\n    else:\n        cv2.putText(frame_display, \"PELOTA NO DETECTADA O FUERA DEL PLATO\", \n                    (10, frame_display.shape[0]-20), font, 0.5, (0,165,255), 2)\n\n    cv2.imshow('CONTROL DE BALANZA (PID ACTIVO)', frame_display)\n    cv2.imshow('Imagen de Deteccion (Solo Plato Visible)', frame_deteccion)\n\n    if cv2.waitKey(1) &amp; 0xFF == ord('q'):\n        break\n\n    time.sleep(pid_dt) \n\n# ===================== LIMPIEZA =====================\nprint(\"\\n\u2713 Sistema cerrado. Centrando Servos...\")\nif arduino is not None:\n    comando_cierre = f\"A1:{current_base},A2:{current_base},A3:{current_base}\\n\"\n    arduino.write(comando_cierre.encode('ascii'))\n    time.sleep(0.5)\n    arduino.close()\n\ncap.release()\ncv2.destroyAllWindows()\n</code></pre>"},{"location":"balansa/BalsaStewart/#9-videos","title":"9. Videos","text":""},{"location":"balansa/CalibracionC/","title":"Balanza PID 3D - 6 Cuadrantes Polares","text":""},{"location":"balansa/CalibracionC/#objetivo","title":"Objetivo","text":"<p>Crear sistema de seguimiento que divide la imagen en 6 sectores polares de 60\u00b0 m\u00e1s zonas centro superior/inferior, con slicers interactivos para filtrar \u00e1rea y control PID que env\u00eda comandos a Arduino.</p>"},{"location":"balansa/CalibracionC/#arquitectura-dual-ventana","title":"Arquitectura Dual Ventana","text":"<p>VENTANA 1 'Camera': Video en vivo + 6 radios + detecci\u00f3n polar + PID VENTANA 2 'SLICER': Controles interactivos min/max \u00e1rea</p>"},{"location":"balansa/CalibracionC/#1-division-polar-6-cuadrantes","title":"1. Divisi\u00f3n Polar 6 Cuadrantes","text":"<pre><code>def obtener_cuadrante_6(cx, cy, centrox, centroy):\n    dx = cx - centrox; dy = cy - centroy\n    distancia = math.sqrt(dx**2 + dy**2)\n\n    if distancia &lt; 50:  # Zona CENTRO\n        return \"CENTRO_SUP/INF\", 0.0, 0.0, color_amarillo/cyan\n\n    angulo = math.atan2(dy, dx) * 180 / math.pi  # 0\u00b0=derecha\n    if angulo &lt; 0: angulo += 360\n    sector = int(angulo // 60)  # 6 sectores 60\u00b0\n</code></pre> <p>Sectores: 0\u00b0(Der-Rojo), 60\u00b0(Naranja), 120\u00b0(Magenta), 180\u00b0(Cian), 240\u00b0(Rosa), 300\u00b0(Verde)</p>"},{"location":"balansa/CalibracionC/#2-errores-normalizados-polares","title":"2. Errores Normalizados Polares","text":"<pre><code>error_magnitud = np.clip(distancia / 250, 0, 1.0)  # 0=centro, 1=borde\nerrorX_norm = (dx / distancia) * error_magnitud\nerrorY_norm = (dy / distancia) * error_magnitud\n</code></pre> <p>Vector unitario \u00d7 magnitud: Error direccional ponderado por distancia.</p>"},{"location":"balansa/CalibracionC/#3-comunicacion-serial-arduino","title":"3. Comunicaci\u00f3n Serial Arduino","text":"<pre><code>PUERTO_SERIAL = 'COM11'; BAUDRATE = 11520\narduino = serial.Serial(PUERTO_SERIAL, BAUDRATE, timeout=0.01)\ntime.sleep(2)  # Reset Arduino\n</code></pre> <p>Comando: \"X:45,Y:-12,Z:78\\n\" \u2192 Servos pines 11,6,5</p>"},{"location":"balansa/CalibracionC/#4-controladores-pid-3-ejes","title":"4. Controladores PID (3 ejes)","text":"<pre><code>pid_x = PID(Kp=0.8, Ki=0.05, Kd=0.15)     # Horizontal\npid_y = PID(Kp=0.8, Ki=0.05, Kd=0.15)     # Vertical\npid_area = PID(Kp=0.3, Ki=0.02, Kd=0.08, setpoint=2000)  # Distancia\n</code></pre> <p>Escalado: errorX_norm * 100 \u2192 salida \u00b190\u00b0 servo</p>"},{"location":"balansa/CalibracionC/#5-slicers-interactivos-minmax-area","title":"5. Slicers Interactivos (min/max \u00e1rea)","text":"<pre><code>def dibujar_slicer(frame, y_pos, valor, label, min_val, max_val, color):\n    cv2.rectangle(frame, (10, y_pos), (310, y_pos+30), (50,50,50), -1)  # Fondo\n    proporcion = (valor - min_val) / (max_val - min_val)\n    cv2.rectangle(frame, (10, y_pos), (10+int(proporcion*300), y_pos+30), color, -1)\n</code></pre> <p>Controles: Rueda mouse \u2191\u2193 | A/Z:min\u00b1100 | S/X:max\u00b1200</p>"},{"location":"balansa/CalibracionC/#6-deteccion-visual-optimizada","title":"6. Detecci\u00f3n Visual Optimizada","text":"<pre><code>hsv = cv2.cvtColor(frame, cv2.COLOR_BGR2HSV)\nmask1 = cv2.inRange(hsv, [0,150,50], [8,255,255])     # Rojo1\nmask2 = cv2.inRange(hsv, [170,150,50], [179,255,255]) # Rojo2\nmask = cv2.add(mask1, mask2)\n</code></pre> <p>Filtro \u00e1rea: min_area(100)-max_area(8000) elimina ruido/objetos grandes</p>"},{"location":"balansa/CalibracionC/#7-visualizacion-6-radios-polares","title":"7. Visualizaci\u00f3n 6 Radios Polares","text":"<pre><code>radio_lineas = 150\nfor angulo in range(0, 360, 60):  # Cada 60\u00b0\n    x_fin = centrox + radio_lineas * math.cos(math.radians(angulo))\n    y_fin = centroy + radio_lineas * math.sin(math.radians(angulo))\n    cv2.line(frame, (centrox, centroy), (x_fin, y_fin), (0,255,0), 2)\n</code></pre> <p>6 l\u00edneas verdes: Dividen imagen en sectores polares precisos.</p>"},{"location":"balansa/CalibracionC/#8-flujo-principal-dual-ventana","title":"8. Flujo Principal Dual Ventana","text":"<pre><code>while True:\n    frame = cap.read() \u2192 flip(1)\n    # 1. HSV \u2192 Morfolog\u00eda \u2192 Contornos filtrados\n    # 2. Mejor contorno \u2192 cuadrante_6() \u2192 errores normalizados\n    # 3. PID \u2192 outputX/Y/Z \u2192 Serial Arduino\n    # 4. Dibujar: centro+radio50+6lineas+target+cuadrante\n    # 5. frame_slicer \u2192 2 slicers + cursor mouse\n    cv2.imshow('Camera', frame)\n    cv2.imshow('SLICER', frame_slicer)\n</code></pre>"},{"location":"balansa/CalibracionC/#9-controles-interactivos-completos","title":"9. Controles Interactivos Completos","text":"<p>TECLADO: A/Z: min_area \u00b1100 S/X: max_area \u00b1200 Q: Salir</p> <p>RAT\u00d3N (ventana SLICER): \u2191\u2193Rueda sobre slicer1: min_area \u00b150 \u2191\u2193Rueda sobre slicer2: max_area \u00b1100</p>"},{"location":"balansa/CalibracionC/#10-informacion-en-pantalla-tiempo-real","title":"10. Informaci\u00f3n en Pantalla Tiempo Real","text":"<p>CENTRO: C\u00edrculo verde r=10 + borde r=50 (zona CENTRO) TARGET: C\u00edrculo coloreado por cuadrante r=8 RADIO: 6 l\u00edneas verdes 150px cada 60\u00b0 TEXTO: Cuadrante | X/Y_norm | \u00c1rea | PID_XYZ SLICER: min_area(verde) | max_area(naranja)</p>"},{"location":"balansa/CalibracionC/#11-limpieza-segura","title":"11. Limpieza Segura","text":"<pre><code>arduino.write(b\"X:0,Y:0,Z:0\\n\")  # Servos neutral\ntime.sleep(0.5)  # Movimiento completo\ncap.release()\narduino.close()\ncv2.destroyAllWindows()\n</code></pre>"},{"location":"balansa/CalibracionC/#valores-iniciales-recomendados","title":"Valores Iniciales Recomendados","text":"<p>min_area = 100    # Elimina ruido peque\u00f1o max_area = 8000   # Limita objetos grandes setpoint_area = 2000  # Tama\u00f1o objetivo pelota radio_centro = 50     # Zona muerta central radio_lineas = 150    # Visualizaci\u00f3n sectores</p>"},{"location":"balansa/CalibracionC/#problemas-comunes-y-soluciones","title":"Problemas Comunes y Soluciones","text":"Problema Causa Soluci\u00f3n No detecta \u00c1rea fuera rango Ajustar slicers A/Z/S/X Cuadrante err\u00f3neo Pelota en borde \u2191radio_centro (60-80) PID inestable Error muy peque\u00f1o errorX_norm * 150 Servos no responden Serial Verificar COM11/11520"},{"location":"balansa/CalibracionC/#evidencias","title":"Evidencias","text":""},{"location":"balansa/CalibracionP/","title":"Calibrador HoughCircles - Plato Circular","text":""},{"location":"balansa/CalibracionP/#objetivo","title":"Objetivo","text":"<p>Crear una interfaz interactiva que permita ajustar en tiempo real los 6 par\u00e1metros de cv2.HoughCircles para detectar platos circulares de forma \u00f3ptima, guardando valores finales para c\u00f3digo principal.</p>"},{"location":"balansa/CalibracionP/#parametros-houghcircles-explicados","title":"Par\u00e1metros HoughCircles Explicados","text":"Par\u00e1metro Funci\u00f3n Rango t\u00edpico Efecto visual dp Resoluci\u00f3n acumulador (1=imagen, 2=mitad) 0.8-2.0 Precisi\u00f3n vs velocidad minDist Distancia m\u00ednima c\u00edrculos 100-400px Evita detecci\u00f3n m\u00faltiple param1 Umbral Canny (bordes) 50-200 Sensibilidad bordes param2 Umbral acumulador c\u00edrculo 15-60 Confianza detecci\u00f3n minRadius Radio m\u00ednimo c\u00edrculo 80-200px Filtra c\u00edrculos peque\u00f1os maxRadius Radio m\u00e1ximo c\u00edrculo 200-400px Filtra c\u00edrculos grandes"},{"location":"balansa/CalibracionP/#1-inicializacion-y-ventana-interactiva","title":"1. Inicializaci\u00f3n y Ventana Interactiva","text":"<pre><code>cap = cv2.VideoCapture(0)\ncap.set(cv2.CAP_PROP_FRAME_WIDTH, 640)\ncap.set(cv2.CAP_PROP_FRAME_HEIGHT, 480)\n\nventana_calibrador = 'HOUGH CIRCLES CALIBRADOR'\ncv2.namedWindow(ventana_calibrador)\ncv2.setMouseCallback(ventana_calibrador, mouse_callback)\n</code></pre> <ul> <li>640x480: Resoluci\u00f3n fija para slicers consistentes</li> <li>mouse_callback: Detecta rueda del mouse sobre slicers</li> </ul>"},{"location":"balansa/CalibracionP/#2-frame-slicers-panel-de-control","title":"2. Frame Slicers (Panel de Control)","text":"<pre><code>frame_slicers = np.zeros((480, 640, 3), dtype=np.uint8)\nframe_slicers.fill(30)  # Fondo gris oscuro\n</code></pre> <p>Crea panel negro separado (mismo tama\u00f1o c\u00e1mara) para 6 slicers horizontales.</p>"},{"location":"balansa/CalibracionP/#3-funcion-dibujar_slicer","title":"3. Funci\u00f3n dibujar_slicer()","text":"<pre><code>def dibujar_slicer(frame, y_pos, valor, label, min_val, max_val, color):\n    # Barra fondo gris\n    cv2.rectangle(frame, (20, y_pos), (620, y_pos+35), (60,60,60), -1)\n    # Barra progreso coloreada\n    proporcion = (valor - min_val) / (max_val - min_val)\n    ancho_activo = int(proporcion * 600)\n    cv2.rectangle(frame, (20, y_pos+5), (20+ancho_activo, y_pos+30), color, -1)\n    # Etiqueta con valor actual\n    cv2.putText(frame, f'{label}: {valor:.1f}', (20, y_pos-8), cv2.FONT_HERSHEY_SIMPLEX, 0.6, (255,255,255), 2)\n</code></pre> <p>Cada slicer: Barra gris + progreso coloreado + texto valor/rango.</p>"},{"location":"balansa/CalibracionP/#4-deteccion-houghcircles-en-tiempo-real","title":"4. Detecci\u00f3n HoughCircles en Tiempo Real","text":"<pre><code>gray = cv2.cvtColor(frame, cv2.COLOR_BGR2GRAY)\nblurred = cv2.GaussianBlur(gray, (5, 5), 0)  # Suavizado esencial\n\ncircles = cv2.HoughCircles(\n    blurred, cv2.HOUGH_GRADIENT, \n    dp=float(dp), minDist=int(minDist),\n    param1=int(param1), param2=int(param2),\n    minRadius=int(minRadius), maxRadius=int(maxRadius)\n)\n</code></pre> <p>GaussianBlur(5,5): Elimina ruido antes de Hough (cr\u00edtico).</p>"},{"location":"balansa/CalibracionP/#5-seleccion-mejor-circulo","title":"5. Selecci\u00f3n Mejor C\u00edrculo","text":"<pre><code>if circles is not None:\n    circles = np.round(circles[0, :]).astype(\"int\")\n    areas = [r*r for _,_,r in circles]  # \u00c1rea = \u03c0r\u00b2 \u2248 r\u00b2\n    mejor_idx = np.argmax(areas)  # MAYOR = m\u00e1s confiable\n    mejor_plato = circles[mejor_idx]\n</code></pre> <p>Criterio: El c\u00edrculo de mayor radio es el plato principal.</p>"},{"location":"balansa/CalibracionP/#6-visualizacion-inteligente","title":"6. Visualizaci\u00f3n Inteligente","text":""},{"location":"balansa/CalibracionP/#todos-los-circulos-transparencia-por-confianza","title":"TODOS los c\u00edrculos (transparencia por confianza)","text":"<pre><code>for i, (x, y, r) in enumerate(circles):\n    alpha = 0.3 + 0.7 * (r*r / max(areas))  # Mayor \u00e1rea = m\u00e1s visible\n    color = (0, int(255*alpha), 0)\n    cv2.circle(frame, (x, y), r, color, 2)\n\n# MEJOR PLATO (verde grueso)\ncv2.circle(frame, (x, y), r, (0,255,0), 3)\ncv2.circle(frame, (x, y), 6, (0,255,0), -1)\n</code></pre> <p>Alpha din\u00e1mico: C\u00edrculos peque\u00f1os semitransparentes, grandes=opacos.</p>"},{"location":"balansa/CalibracionP/#7-controles-interactivos","title":"7. Controles Interactivos","text":""},{"location":"balansa/CalibracionP/#rueda-del-mouse-sobre-slicers","title":"Rueda del Mouse (sobre slicers)","text":"<pre><code>if event == cv2.EVENT_MOUSEWHEEL:\n    delta = 0.05 if event &gt; 0 else -0.05\n    if y_slicer &lt;= y &lt;= y_slicer+33:  # Zona DP\n        dp = np.clip(dp + delta, 0.8, 2.0)\n</code></pre>"},{"location":"balansa/CalibracionP/#teclado-rapido","title":"Teclado r\u00e1pido","text":"<p>Q/A: dp \u00b10.1    D/E: minDist \u00b120 Z/X: param1 \u00b110  C/V: param2 \u00b15 B/N: minR \u00b110    ,/.: maxR \u00b120 ESPACIO: Guardar  ESC: Salir</p>"},{"location":"balansa/CalibracionP/#8-interfaz-combinada","title":"8. Interfaz Combinada","text":"<pre><code>frame_combinado = np.hstack([frame, frame_slicers])  # Izquierda=Derecha\ncv2.imshow(ventana_calibrador, frame_combinado)\n</code></pre> <p>hstack: C\u00e1mara (640px) + Slicers (640px) = 1280px ancho.</p>"},{"location":"balansa/CalibracionP/#9-guardado-valores-optimos","title":"9. Guardado Valores \u00d3ptimos","text":"<pre><code>if tecla == 32:  # ESPACIO\n    valores_optimos = {'dp': dp, 'minDist': minDist, ...}\n    print(\"\u2705 VALORES \u00d3PTIMOS GUARDADOS:\")\n</code></pre> <p>Salida lista para copiar a c\u00f3digo principal HoughCircles.</p>"},{"location":"balansa/CalibracionP/#10-valores-iniciales-recomendados","title":"10. Valores Iniciales Recomendados","text":"<p>dp = 1.2        # Resoluci\u00f3n media minDist = 200   # Platos ~20cm separados param1 = 100    # Bordes medios param2 = 30     # Confianza media minRadius = 120 # Platos ~12cm di\u00e1metro maxRadius = 300 # Hasta ~30cm</p>"},{"location":"balansa/CalibracionP/#uso-practico","title":"Uso Pr\u00e1ctico","text":"<ol> <li>Ejecutar calibrador \u2192 apuntar c\u00e1mara a platos</li> <li>Ajustar slicers con rueda/teclado hasta detectar 1 c\u00edrculo verde grueso</li> <li>ESPACIO \u2192 copiar valores impresos</li> <li>Pegar en c\u00f3digo principal:</li> </ol> <pre><code>circles = cv2.HoughCircles(blurred, cv2.HOUGH_GRADIENT, \n    dp=1.2, minDist=200, param1=100, param2=30, \n    minRadius=120, maxRadius=300)\n</code></pre>"},{"location":"balansa/CalibracionP/#problemas-comunes","title":"Problemas Comunes","text":"S\u00edntoma Soluci\u00f3n Demasiados c\u00edrculos \u2191minDist, \u2193param2 No detecta plato \u2193param1, \u2191param2, \u2193dp C\u00edrculos muy peque\u00f1os \u2191minRadius Demasiado lento \u2191dp (1.5-2.0) Bordes ruidosos GaussianBlur(7,7)"},{"location":"balansa/CalibracionP/#evidencias","title":"Evidencias","text":""},{"location":"balansa/Opencv/","title":"Balanza PID 3D - OpenCV + Arduino","text":""},{"location":"balansa/Opencv/#objetivo","title":"Objetivo","text":"<p>Crear una plataforma aut\u00f3noma que siga un objeto de color espec\u00edfico moviendo 3 servos usando visi\u00f3n por computadora y control PID avanzado.</p>"},{"location":"balansa/Opencv/#1-inicializacion-camara-cv2videocapture","title":"1. Inicializaci\u00f3n C\u00e1mara (cv2.VideoCapture)","text":""},{"location":"balansa/Opencv/#por-que-videocapture0","title":"\u00bfPor qu\u00e9 VideoCapture(0)?","text":"<pre><code>cap = cv2.VideoCapture(0) # 0 = c\u00e1mara predeterminada (webcam)\n</code></pre> <ul> <li><code>0</code> = primera c\u00e1mara detectada (webcam USB/interna)</li> <li><code>1</code> = segunda c\u00e1mara, etc.</li> <li>IMPORTANTE: Siempre cerrar con <code>cap.release()</code> para liberar el dispositivo</li> </ul>"},{"location":"balansa/Opencv/#ciclo-de-vida-camara","title":"Ciclo de vida c\u00e1mara","text":"<pre><code>\u2705 CORRECTO\ncap = cv2.VideoCapture(0)\nwhile True:\nret, frame = cap.read() # ret=True si lee bien\nif not ret: break\n\n...\ncap.release() # Libera c\u00e1mara para otras apps\ncv2.destroyAllWindows() # Cierra ventanas OpenCV\n\n\u274c ERROR: C\u00e1mara queda \"bloqueada\"\ncap = cv2.VideoCapture(0)\nwhile True:\nret, frame = cap.read()\n# Sin release() \u2192 otras apps no acceden c\u00e1mara\n</code></pre>"},{"location":"balansa/Opencv/#2-comunicacion-serial-completa","title":"2. Comunicaci\u00f3n Serial Completa","text":""},{"location":"balansa/Opencv/#inicializacion-robusta","title":"Inicializaci\u00f3n robusta","text":"<pre><code>PUERTO_SERIAL = 'COM11'\nBAUDRATE = 11520\nTIMEOUT = 0.01\n\ntry:\narduino = serial.Serial(PUERTO_SERIAL, BAUDRATE, timeout=TIMEOUT)\ntime.sleep(2) # Arduino necesita 2s para reset+boot\nprint(\"\u2713 Serial conectado\")\nexcept:\nprint(\"\u2717 Puerto no disponible\")\nexit()\n</code></pre> <p>time.sleep(2): Arduino hace reset al conectar USB, necesita tiempo para cargar sketch.</p>"},{"location":"balansa/Opencv/#envio-de-comandos","title":"Env\u00edo de comandos","text":"<pre><code>comando = f\"X:{int(outputX)},Y:{int(outputY)},Z:{int(outputArea)}\\n\"\narduino.write(comando.encode()) # String \u2192 bytes\n</code></pre> <ul> <li><code>\\n</code> = terminador necesario para <code>readStringUntil('\\n')</code> en Arduino</li> <li><code>encode()</code> convierte string Python a bytes seriales</li> </ul>"},{"location":"balansa/Opencv/#cierre-seguro","title":"Cierre seguro","text":"<pre><code>Antes de salir\narduino.write(b\"X:0,Y:0,Z:0\\n\") # Servos a posici\u00f3n segura\ntime.sleep(0.5) # Servo llega a posici\u00f3n\narduino.close() # Libera puerto serial\n</code></pre>"},{"location":"balansa/Opencv/#3-clase-pid-explicacion-matematica","title":"3. Clase PID - Explicaci\u00f3n Matem\u00e1tica","text":"<pre><code>class PID:\ndef update(self, measurement):\nerror = self.setpoint - measurement # Error actual\n</code></pre> <pre><code>self.integral += error * self.dt     # \u2211error\u00b7\u0394t (acumula)\nself.integral = np.clip(self.integral, -50, 50)  # Anti-windup\n\nderivative = (error - self.prev_error) / self.dt  # \u0394error/\u0394t\nself.output = (self.Kp*error + \n              self.Ki*self.integral + \n              self.Kd*derivative)\nself.output = np.clip(self.output, -90, 90)  # L\u00edmite servo\n\nself.prev_error = error\nreturn self.output\n</code></pre> <p>np.clip(): Evita que servos vayan m\u00e1s all\u00e1 de l\u00edmites f\u00edsicos.</p>"},{"location":"balansa/Opencv/#4-deteccion-hsv-por-que-dos-rangos-para-rojo","title":"4. Detecci\u00f3n HSV - \u00bfPor qu\u00e9 dos rangos para rojo?","text":"<pre><code>Rojo envuelve H=0\u00b0 y H=180\u00b0 (c\u00edrculo HSV)\nredbajo1 = np.array() # Rojo inicial (0-8)\u200b\nredalto1 = np.array()\nredbajo2 = np.array() # Rojo final (170-179)\u200b\nredalto2 = np.array()\nmask = cv2.add(mask1, mask2) # Combina ambos\n</code></pre> <p>S=150, V=50: Filtra rojos saturados y brillantes, elimina sombras/grises.</p>"},{"location":"balansa/Opencv/#5-procesamiento-morfologico","title":"5. Procesamiento Morfol\u00f3gico","text":"<pre><code>kernel = cv2.getStructuringElement(cv2.MORPH_ELLIPSE, (5,5))\nmask = cv2.morphologyEx(mask, cv2.MORPH_OPEN, kernel) # Elimina ruido\nmask = cv2.morphologyEx(mask, cv2.MORPH_CLOSE, kernel) # Une huecos\n</code></pre> <ul> <li>OPEN: Erosi\u00f3n \u2192 Dilataci\u00f3n = elimina puntos sueltos</li> <li>CLOSE: Dilataci\u00f3n \u2192 Erosi\u00f3n = une regiones separadas</li> <li>ELLIPSE: M\u00e1s suave que rect\u00e1ngulo</li> </ul>"},{"location":"balansa/Opencv/#6-seleccion-mejor-contorno","title":"6. Selecci\u00f3n Mejor Contorno","text":"<pre><code>for c in contornos:\narea = cv2.contourArea(c)\nif 100 &lt; area &lt; 8000: # Filtra ruido/objetos grandes\nM = cv2.moments(c)\nif M[\"m00\"] != 0: # \u00c1rea v\u00e1lida\ncx = int(M[\"m10\"] / M[\"m00\"]) # Centro X\ncy = int(M[\"m01\"] / M[\"m00\"]) # Centro Y\nif area &gt; mejor_area: # Mayor = objetivo principal\nmejor_contorno = c\n</code></pre> <p>m00=0: Contorno con \u00e1rea cero (inv\u00e1lido).</p>"},{"location":"balansa/Opencv/#7-filtro-exponencial-estabilidad","title":"7. Filtro Exponencial (Estabilidad)","text":"<pre><code>alpha = 0.6 # 60% nuevo, 40% anterior\nerrorX = alpha * errorX_raw + (1-alpha) * prev_errorX\n</code></pre> <p>Ejemplo: Error raw: 10\u219250\u2192-20 \u2192 Filtrado: 10\u219228\u219216 (suave).</p>"},{"location":"balansa/Opencv/#8-bucle-principal-explicado","title":"8. Bucle Principal Explicado","text":"<pre><code>while True:\nret, frame = cap.read()\nif not ret: break # C\u00e1mara desconectada\n</code></pre> <p>frame = cv2.flip(frame, 1)  # Espejo (intuitivo) centrox = frame.shape // 2  # Centro ancho[2] centroy = frame.shape // 2  # Centro alto</p>"},{"location":"balansa/Opencv/#deteccion-hsv-pid-serial-visualizar","title":"[Detecci\u00f3n HSV \u2192 PID \u2192 Serial \u2192 Visualizar]","text":"<p>if cv2.waitKey(1) &amp; 0xFF == ord('q'):  # ESC o 'q'     break</p> <p>waitKey(1): 1ms delay, ~1000 FPS m\u00e1ximo (limitado por c\u00e1mara).</p>"},{"location":"balansa/Opencv/#9-visualizacion-informativa","title":"9. Visualizaci\u00f3n Informativa","text":"<pre><code>cv2.circle(frame, (centrox, centroy), 8, (0,255,0), -1) # Centro VERDE\ncv2.circle(frame, (mejor_cx, mejor_cy), 7, (0,0,255), -1) # Target ROJO\ncv2.drawContours(frame, [hull], 0, (255,255,0), 2) # Contorno CYAN\ncv2.putText(frame, f'X11:{int(outputX)}', ...) # Valores PID\n</code></pre>"},{"location":"balansa/Opencv/#10-limpieza-final-critica","title":"10. Limpieza Final (CR\u00cdTICA)","text":"<pre><code>1. Servos a posici\u00f3n segura\narduino.write(b\"X:0,Y:0,Z:0\\n\")\ntime.sleep(0.5) # Servo se mueve\n\n2. Liberar recursos\ncap.release() # C\u00e1mara libre para otras apps\narduino.close() # Puerto serial libre\ncv2.destroyAllWindows() # Cierra todas ventanas OpenCV\n</code></pre> <p>Sin release(): C\u00e1mara queda bloqueada, serial ocupado.</p>"},{"location":"balansa/Opencv/#codigo-arduino-completo","title":"C\u00f3digo Arduino Completo","text":"<pre><code>#include &lt;Servo.h&gt;\nServo servoX(11), servoY(6), servoZ(5);\n\nvoid setup() {\nSerial.begin(11520);\nservoX.write(90); servoY.write(90); servoZ.write(90); // Neutral\n}\n\nvoid loop() {\nif (Serial.available()) {\nString cmd = Serial.readStringUntil('\\n');\n// Parsing robusto con \u00edndices\nint x = cmd.substring(cmd.indexOf(\"X:\")+2, cmd.indexOf(\",Y\")).toInt();\nservoX.write(map(x, -90,90,0,180));\n}\n}\n</code></pre> <p>int x = cmd.substring(idxX, cmd.indexOf(\",\", idxX)).toInt(); int y = cmd.substring(idxY, cmd.indexOf(\",\", idxY)).toInt(); int z = cmd.substring(idxZ).toInt();</p> <p>servoX.write(map(x, -90, 90, 0, 180)); servoY.write(map(y, -90, 90, 0, 180)); servoZ.write(map(z, -90, 90, 0, 180));</p>"},{"location":"balansa/Opencv/#tabla-hsv-por-color-objetivo","title":"Tabla HSV por Color Objetivo","text":"Color H_bajo1 H_alto1 H_bajo2 H_alto2 S_min V_min Rojo 0 8 170 179 150 50 Verde 50 75 - - 100 50 Azul 100 130 - - 100 50 Amarillo 20 35 - - 150 100 Naranja 10 25 - - 150 100 P\u00farpura 140 160 - - 100 50 Rosa 160 175 - - 100 100 Cian 80 100 - - 100 100 <p>Uso: Reemplazar rangos rojo por el color deseado en el c\u00f3digo.</p>"},{"location":"balansa/Opencv/#codigo-python-completo","title":"C\u00f3digo Python Completo","text":""},{"location":"balansa/Opencv/#import-cv2-import-numpy-as-np-import-serial-import-serialtoolslist_ports-import-time-puerto_serial-com11-baudrate-11520-timeout-001-try-arduino-serialserialpuerto_serial-baudrate-timeouttimeout-timesleep2-print-serial-conectado-except-print-error-puerto-exit-class-pid-def-initself-kp-ki-kd-setpoint0-dt003-selfkp-kp-selfki-ki-selfkd-kd-selfsetpoint-setpoint-selfdt-dt-selfprev_error-0-selfintegral-0-selfoutput-0-def-updateself-measurement-error-selfsetpoint-measurement-selfintegral-error-selfdt-selfintegral-npclipselfintegral-50-50-derivative-error-selfprev_error-selfdt-selfoutput-selfkperror-selfkiselfintegral-selfkdderivative-selfoutput-npclipselfoutput-90-90-selfprev_error-error-return-selfoutput-pid_x-pid08-005-015-pid_y-pid08-005-015-pid_area-pid03-002-008-setpoint2000-cap-cv2videocapture0-alpha-06-prev_errorx-prev_errory-0-0-print-balanza-pid-3d-while-true-ret-frame-capread-if-not-ret-break-frame-cv2flipframe-1-centrox-frameshape-22-centroy-frameshape-2-hsv-cv2cvtcolorframe-cv2color_bgr2hsv-redbajo1-nparray-redalto1-nparray1-redbajo2-nparray-redalto2-nparray1-mask1-cv2inrangehsv-redbajo1-redalto1-mask2-cv2inrangehsv-redbajo2-redalto2-mask-cv2addmask1-mask2-kernel-cv2getstructuringelementcv2morph_ellipse-55-mask-cv2morphologyexmask-cv2morph_open-kernel-mask-cv2morphologyexmask-cv2morph_close-kernel-contornos-_-cv2findcontoursmask-cv2retr_external-cv2chain_approx_simple-mejor_contorno-none-mejor_cx-mejor_cy-mejor_area-none-none-0-for-c-in-contornos-area-cv2contourareac-if-100-area-8000-m-cv2momentsc-if-mm00-0-cx-intmm10-mm00-cy-intmm01-mm00-if-area-mejor_area-mejor_contorno-c-mejor_cx-mejor_cy-cx-cy-mejor_area-area-if-mejor_contorno-is-not-none-errorx_raw-mejor_cx-centrox-errory_raw-mejor_cy-centroy-errorx-alpha-errorx_raw-1-alpha-prev_errorx-errory-alpha-errory_raw-1-alpha-prev_errory-prev_errorx-prev_errory-errorx-errory-outputx-pid_xupdateerrorx-outputy-pid_yupdateerrory-outputarea-pid_areaupdatemejor_area-comando-fxintoutputxyintoutputyzintoutputarean-arduinowritecomandoencode-cv2circleframe-intmejor_cx-intmejor_cy-7-00255-1-hull-cv2convexhullmejor_contorno-cv2drawcontoursframe-hull-0-2552550-2-else-arduinowritebx0y0z0n-cv2circleframe-centrox-centroy-8-02550-1-cv2imshowbalanza-pid-3d-frame-if-cv2waitkey1-0xff-ordq-break-arduinowritebx0y0z0n-timesleep05-caprelease-arduinoclose-cv2destroyallwindows-print-sistema-cerrado","title":"<pre><code>import cv2\nimport numpy as np\nimport serial\nimport serial.tools.list_ports\nimport time\n\nPUERTO_SERIAL = 'COM11'\nBAUDRATE = 11520\nTIMEOUT = 0.01\n\ntry:\narduino = serial.Serial(PUERTO_SERIAL, BAUDRATE, timeout=TIMEOUT)\ntime.sleep(2)\nprint(\"\u2713 Serial conectado\")\nexcept:\nprint(\"\u2717 ERROR puerto\")\nexit()\n\nclass PID:\ndef init(self, Kp, Ki, Kd, setpoint=0, dt=0.03):\nself.Kp = Kp; self.Ki = Ki; self.Kd = Kd\nself.setpoint = setpoint; self.dt = dt\nself.prev_error = 0; self.integral = 0; self.output = 0\n\ndef update(self, measurement):\n    error = self.setpoint - measurement\n    self.integral += error * self.dt\n    self.integral = np.clip(self.integral, -50, 50)\n    derivative = (error - self.prev_error) / self.dt\n    self.output = self.Kp*error + self.Ki*self.integral + self.Kd*derivative\n    self.output = np.clip(self.output, -90, 90)\n    self.prev_error = error\n    return self.output\n\npid_x = PID(0.8, 0.05, 0.15)\npid_y = PID(0.8, 0.05, 0.15)\npid_area = PID(0.3, 0.02, 0.08, setpoint=2000)\n\ncap = cv2.VideoCapture(0)\nalpha = 0.6\nprev_errorX, prev_errorY = 0, 0\n\nprint(\"\ud83c\udfaf BALANZA PID 3D\")\nwhile True:\nret, frame = cap.read()\nif not ret: break\n\nframe = cv2.flip(frame, 1)\ncentrox = frame.shape // 2[2]\ncentroy = frame.shape // 2\n\nhsv = cv2.cvtColor(frame, cv2.COLOR_BGR2HSV)\nredbajo1 = np.array(); redalto1 = np.array()[1]\nredbajo2 = np.array(); redalto2 = np.array()[1]\n\nmask1 = cv2.inRange(hsv, redbajo1, redalto1)\nmask2 = cv2.inRange(hsv, redbajo2, redalto2)\nmask = cv2.add(mask1, mask2)\n\nkernel = cv2.getStructuringElement(cv2.MORPH_ELLIPSE, (5,5))\nmask = cv2.morphologyEx(mask, cv2.MORPH_OPEN, kernel)\nmask = cv2.morphologyEx(mask, cv2.MORPH_CLOSE, kernel)\n\ncontornos, _ = cv2.findContours(mask, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)\n\nmejor_contorno = None; mejor_cx, mejor_cy, mejor_area = None, None, 0\n\nfor c in contornos:\n    area = cv2.contourArea(c)\n    if 100 &lt; area &lt; 8000:\n        M = cv2.moments(c)\n        if M[\"m00\"] != 0:\n            cx = int(M[\"m10\"] / M[\"m00\"])\n            cy = int(M[\"m01\"] / M[\"m00\"])\n            if area &gt; mejor_area:\n                mejor_contorno = c\n                mejor_cx, mejor_cy = cx, cy\n                mejor_area = area\n\nif mejor_contorno is not None:\n    errorX_raw = mejor_cx - centrox\n    errorY_raw = mejor_cy - centroy\n    errorX = alpha * errorX_raw + (1-alpha) * prev_errorX\n    errorY = alpha * errorY_raw + (1-alpha) * prev_errorY\n    prev_errorX, prev_errorY = errorX, errorY\n\n    outputX = pid_x.update(errorX)\n    outputY = pid_y.update(errorY)\n    outputArea = pid_area.update(mejor_area)\n\n    comando = f\"X:{int(outputX)},Y:{int(outputY)},Z:{int(outputArea)}\\n\"\n    arduino.write(comando.encode())\n\n    cv2.circle(frame, (int(mejor_cx), int(mejor_cy)), 7, (0,0,255), -1)\n    hull = cv2.convexHull(mejor_contorno)\n    cv2.drawContours(frame, [hull], 0, (255,255,0), 2)\nelse:\n    arduino.write(b\"X:0,Y:0,Z:0\\n\")\n\ncv2.circle(frame, (centrox, centroy), 8, (0,255,0), -1)\ncv2.imshow('BALANZA PID 3D', frame)\n\nif cv2.waitKey(1) &amp; 0xFF == ord('q'): break\n\narduino.write(b\"X:0,Y:0,Z:0\\n\")\ntime.sleep(0.5)\ncap.release()\narduino.close()\ncv2.destroyAllWindows()\nprint(\"\u2713 Sistema cerrado\")\n</code></pre>","text":""},{"location":"balansa/Opencv/#evidencias","title":"Evidencias","text":""},{"location":"recursos/about/","title":"Quien soy?","text":"<p>Mi nombre es Sebasti\u00e1n G\u00f3mez Rodr\u00edguez, tengo 18 a\u00f1os, soy de Puebla-Puebla de la universidad Iberoamericana de Puebla, en el cual soy un estudiante de primer semestre en mecatronica.</p>"},{"location":"recursos/about/#contacto","title":"Contacto","text":"<p>Correo: 204486@iberopuebla.mx</p> <p>N\u00famero: +522215290319</p> <p></p>"},{"location":"recursos/about/#mis-intereses","title":"Mis intereses","text":"<p>Algunos de mis intereses son acerca de los deportes, computacion, construcci\u00f3n y/o reparaci\u00f3n de aparatos electr\u00f3nicos, instrumentos musicales, tomar fotografias, surfeo, ski, t y los videojuegos.</p>"},{"location":"recursos/about/#mis-logros","title":"Mis logros","text":"<p>Unos de mis logros son 3er lugar en las Olimpiadas nacionales de mexico como Puebla,3 a\u00f1os seguidos ganando Interjecuiticos con el Instituto Oriente de Puebla certificado de programacion de camaras de seguridad, buceo, fotografo de Munio 2024-2025 y medallista de 3er lugar en taekwondo.</p>"},{"location":"recursos/about/#universidad-iberoamericana","title":"Universidad Iberoamericana","text":"<p>Pagina de la Universidad.</p>"}]}